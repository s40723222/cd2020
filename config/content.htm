<h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>
<h1>Weeks</h1>
<h2>Week1~5</h2>
<p>Week 1</p>
<p>創立個人倉儲 cd2020，建立個人網站</p>
<p>Week 2</p>
<p>將 python 3.7.3 升級成 python 3.8.3</p>
<p>Week 3</p>
<p>進行翻譯</p>
<p>BubbleRob tutorial</p>
<p>This tutorial will try to introduce quite many CoppeliaSim functionalities while designing the simple mobile robot BubbleRob. The CoppeliaSim scene file related to this tutorial is located in CoppeliaSim's installation folder's tutorials/BubbleRob folder. Following figure illustrates the simulation scene that we will design: </p>
<p>本教程將設計簡單的移動機器人BubbleRob並嘗試介紹很多CoppeliaSim功能。與本教程相關的CoppeliaSim場景文件位於CoppeliaSim的安裝文件夾的tutorials / BubbleRob文件夾中。下圖說明了我們將設計的仿真場景：</p>
<p><img alt="" height="319" src="/images/未命名.jpg" width="489"/></p>
<p>Since this tutorial will fly over many different aspects, make sure to also have a look at the other tutorials, mainly the tutorial about building a simulation model. First of all, freshly start CoppeliaSim. The simulator displays a default scene. We will start with the body of BubbleRob.</p>
<p>由於本教程將跨越許多不同的方面，因此請確保也看看其他教程，主要是有關構建仿真模型的教程。首先，重新啟動CoppeliaSim。模擬器顯示默認場景。我們將從BubbleRob的主體開始。</p>
<p>We add a primitive sphere of diameter 0.2 to the scene with [Menu bar --&gt; Add --&gt; Primitive shape --&gt; Sphere]. We adjust the X-size item to 0.2, then click OK. The created sphere will appear in the visibility layer 1 by default, and be dynamic and respondable (since we kept the item Create dynamic and respondable shape enabled). This means that BubbleRob's body will be falling and able to react to collisions with other respondable shapes (i.e. simulated by the physics engine). We can see this is the shape dynamics properties: items Body is respondable and Body is dynamic are enabled. We start the simulation (via the toolbar button, or by pressing &lt;control-space&gt; in the scene window), and copy-and-paste the created sphere (with [Menu bar --&gt; Edit --&gt; Copy selected objects] then [Menu bar --&gt; Edit -&gt; Paste buffer], or with &lt;control-c&gt; then &lt;control-v&gt;): the two spheres will react to collision and roll away. We stop the simulation: the duplicated sphere will automatically be removed. This default behaviour can be modified in the simulation dialog.</p>
<p>我們使用[Menu bar --&gt; Add --&gt; Primitive shape --&gt; Sphere]將直徑為0.2的基本球體添加到場景中。我們將X尺寸項目調整為0.2，然後單擊“確定”。默認情況下，創建的球體將顯示在可見性層1中，並且是動態且可響應的（因為我們已啟用“Create dynamic and responsive shapes”）。這意味著BubbleRob的身體會掉落並且能夠對與其他可響應形狀的碰撞做出反應（即由物理引擎模擬）。我們可以看到這是“Shape dynamics”屬性：啟用了“The body can respond”和“Body is dynamic”項目。我們開始模擬（通過工具欄按鈕，或在場景窗口中按&lt;control-space&gt;），然後復制並粘貼創建的球體（使用[Menu bar --&gt; Edit --&gt; Copy selected objects]，然後[Menu bar --&gt; Edit -&gt; Paste buffer]，或者先按&lt;control-c&gt;，再按&lt;control-v&gt;）：這兩個球將對碰撞做出反應並滾動。我們停止模擬：重複的球體將自動刪除。可以在模擬對話框中修改此默認行為。</p>
<p>We also want the BubbleRob's body to by usable by the other calculation modules (e.g. the minimum distance calculation module). For that reason, we enable Collidable, Measurable, Renderable and Detectable in the object common properties for that shape, if not already enabled. If we wanted, we could now also change the visual appearance of our sphere in the shape properties.</p>
<p>我們還希望BubbleRob的主體可以被其他計算模塊（例如最小距離計算模塊）使用。因此，如果尚未啟用，則在該形狀的對象公共屬性中啟用“Collidable”，“Measurable”，“Renderable”和“Detectable”。如果需要，我們現在還可以在形狀屬性中更改球體的視覺外觀。</p>
<p>Now we open the position dialog on the translation tab, select the sphere representing BubbleRob's body, and enter 0.02 for Along Z. We make sure that the Relative to-item is set to World. Then we click Translate selection. This translates all selected objects by 2 cm along the absolute Z-axis, and effectively lifted our sphere a little bit. In the scene hierarchy, we double-click the sphere's name, so that we can edit its name. We enter bubbleRob and press enter.</p>
<p>現在，我們在“平移”選項卡上打開“位置”對話框，選擇表示BubbleRob身體的球體，並為“沿Z”輸入0.02。確保將“相對於”項設置為“世界”。然後我們點擊翻譯選擇。這會將所有選定對象沿絕對Z軸平移2 cm，並有效地將我們的球體抬高了一點。在場景層次結構中，我們雙擊球體的名稱，以便我們可以編輯其名稱。我們輸入bubbleRob，然後按Enter。</p>
<p>Next we will add a proximity sensor so that BubbleRob knows when it is approaching obstacles: we select [Menu bar --&gt; Add --&gt; Proximity sensor --&gt; Cone type]. In the orientation dialog on the orientation tab, we enter 90 for Around Y and for Around Z, then click Rotate selection. In the position dialog, on the position tab, we enter 0.1 for X-coord. and 0.12 for Z-coord. The proximity sensor is now correctly positioned relative to BubbleRob's body. We double-click the proximity sensor's icon in the scene hierarchy to open its properties dialog. We click Show volume parameter to open the proximity sensor volume dialog. We adjust items Offset to 0.005, Angle to 30 and Range to 0.15. Then, in the proximity sensor properties, we click Show detection parameters. This opens the proximity sensor detection parameter dialog. We uncheck item Don't allow detections if distance smaller than then close that dialog again. In the scene hierarchy, we double-click the proximity sensor's name, so that we can edit its name. We enter bubbleRob_sensingNose and press enter.</p>
<p>接下來，我們將添加一個接近傳感器，以便BubbleRob知道它何時接近障礙物：我們選擇[Menu bar --&gt; Add --&gt; Proximity sensor --&gt; Cone type]。在“方向”選項卡上的“方向”對話框中，我們為“周圍的Y”和“周圍的Z”輸入90，然後單擊“旋轉選擇”。在位置對話框的“位置”選項卡上，為X坐標輸入0.1。 Z坐標為0.12。現在，接近傳感器已相對於BubbleRob的身體正確定位。我們在場景層次中雙擊接近傳感器的圖標以打開其屬性對話框。我們單擊顯示體積參數以打開接近傳感器體積對話框。我們將偏移量調整為0.005，角度調整為30，範圍調整為0.15。然後，在接近傳感器屬性中，單擊“顯示檢測參數”。這將打開接近傳感器檢測參數對話框。如果距離小於則取消選中“不允許檢測”項，然後再次關閉該對話框。在場景層次結構中，我們雙擊接近傳感器的名稱，以便我們可以編輯其名稱。我們輸入bubbleRob_sensingNose並enter。</p>
<p>We select bubbleRob_sensingNose, then control-select bubbleRob, then click [Menu bar --&gt; Edit --&gt; Make last selected object parent]. This attaches the sensor to the body of the robot. We could also have dragged bubbleRob_sensingNose onto bubbleRob in the scene hierarchy. This is what we now have:<br/> <br/> 我們選擇bubbleRob_sensingNose，然後按住Control鍵選擇bubbleRob，然後單擊[Menu bar --&gt; Edit --&gt;將上一個選定的對象設為parent]。這會將傳感器連接到機器人的身體。我們還可以將bubbleRob_sensingNose拖動到場景層次中的bubbleRob上。這就是我們現在擁有的：</p>
<p><img alt="" height="391" src="/images/02.jpg" width="492"/></p>
<p>[Proximity sensor attached to bubbleRob's body]</p>
<p>Next we will take care of BubbleRob's wheels. We create a new scene with [Menu bar --&gt; File --&gt; New scene]. It is often very convenient to work across several scenes, in order to visualize and work only on specific elements. We add a pure primitive cylinder with dimensions (0.08,0.08,0.02). As for the body of BubbleRob, we enable Collidable, Measurable, Renderable and Detectable in the object common properties for that cylinder, if not already enabled. Then we set the cylinder's absolute position to (0.05,0.1,0.04) and its absolute orientation to (-90,0,0). We change the name to bubbleRob_leftWheel. We copy and paste the wheel, and set the absolute Y coordinate of the copy to -0.1. We rename the copy to bubbleRob_rightWheel. We select the two wheels, copy them, then switch back to scene 1, then paste the wheels.</p>
<p>接下來，我們將照顧BubbleRob的車輪。我們使用[Menu bar --&gt; File --&gt; New scene]創建一個新場景。跨多個場景工作通常非常方便，以便可視化並僅對特定元素進行工作。我們添加一個尺寸為（0.08,0.08,0.02）的純原始圓柱體。對於BubbleRob的主體，如果尚未啟用，則在該圓柱的對象通用屬性中啟用Collidable，Measurable，Renderable和Detectable。然後，將圓柱的絕對位置設置為（0.05,0.1,0.04），並將其絕對方向設置為（-90,0,0）。我們將名稱更改為bubbleRob_leftWheel。我們複製並粘貼滾輪，然後將復制的絕對Y坐標設置為-0.1。我們將副本重命名為bubbleRob_rightWheel。我們選擇兩個輪子，複製它們，然後切換回場景1，然後粘貼輪子。</p>
<p>We now need to add joints (or motors) for the wheels. We click [Menu bar --&gt; Add --&gt; Joint --&gt; Revolute] to add a revolute joint to the scene. Most of the time, when adding a new object to the scene, the object will appear at the origin of the world. We Keep the joint selected, then control-select bubbleRob_leftWheel. In the position dialog, on the position tab, we click the Apply to selection button: this positioned the joint at the center of the left wheel. Then, in the orientation dialog, on the orientation tab, we do the same: this oriented the joint in the same way as the left wheel. We rename the joint to bubbleRob_leftMotor. We now double-click the joint's icon in the scene hierarchy to open the joint properties dialog. Then we click Show dynamic parameters to open the joint dynamics properties dialog. We enable the motor, and check item Lock motor when target velocity is zero. We now repeat the same procedure for the right motor and rename it to bubbleRob_rightMotor. Now we attach the left wheel to the left motor, the right wheel to the right motor, then attach the two motors to bubbleRob. This is what we have:</p>
<p>現在，我們需要為車輪添加接頭（或電動機）。我們單擊[Menu bar --&gt; Add --&gt; Joint --&gt; Revolute]將旋轉關節添加到場景。在大多數情況下，將新對象添加到場景時，該對象將出現在世界的起源處。我們保持關節處於選中狀態，然後控制選擇bubbleRob_leftWheel。在位置對話框的“位置”選項卡上，我們單擊“應用於”選擇按鈕：這將關節定位在左輪的中心。然後，在“方向”對話框中的“方向”選項卡上，執行相同的操作：這將關節與左輪定向的方向相同。我們將關節重命名為bubbleRob_leftMotor。現在，我們在場景層次中雙擊關節的圖標以打開關節屬性對話框。然後，單擊“顯示動態參數”以打開關節動力學屬性對話框。我們啟用電動機，然後選中目標速度為零時鎖定電動機。現在，我們對右馬達重複相同的過程，並將其重命名為bubbleRob_rightMotor。現在，我們將左輪連接到左馬達，將右輪連接到右馬達，然後將兩個馬達連接到bubbleRob。這就是我們所擁有的：</p>
<p><img alt="" height="393" src="/images/03.jpg" width="493"/></p>
<p>[Proximity sensor, motors and wheels]</p>
<p>We run the simulation and notice that the robot is falling backwards. We are still missing a third contact point to the floor. We now add a small slider (or caster). In a new scene we and add a pure primitive sphere with diameter 0.05 and make the sphere Collidable, Measurable, Renderable and Detectable (if not already enabled), then rename it to bubbleRob_slider. We set the Material to noFrictionMaterial in the shape dynamics properties. To rigidly link the slider with the rest of the robot, we add a force sensor object with [Menu bar --&gt; Add --&gt; Force sensor]. We rename it to bubbleRob_connection and shift it up by 0.05. We attach the slider to the force sensor, then copy both objects, switch back to scene 1 and paste them. We then shift the force sensor by -0.07 along the absolute X-axis, then attach it to the robot body. If we run the simulation now, we can notice that the slider is slightly moving in relation to the robot body: this is because both objects (i.e. bubbleRob_slider and bubbleRob) are colliding with each other. To avoid strange effects during dynamics simulation, we have to inform CoppeliaSim that both objects do not mutually collide, and we do this in following way: in the shape dynamics properties, for bubbleRob_slider we set the local respondable mask to 00001111, and for bubbleRob, we set the local respondable mask to 11110000. If we run the simulation again, we can notice that both objects do not interfere anymore. This is what we now have:</p>
<p>我們運行模擬，並註意到機器人向後倒下。我們仍然缺少與地板的第三個聯繫點。現在，我們添加一個小的滑塊（或腳輪）。在一個新場景中，我們添加一個直徑為0.05的純原始球體，並使該球體可碰撞，可測量，可渲染和可檢測（如果尚未啟用），然後將其重命名為bubbleRob_slider。我們在形狀動力學屬性中將Material設置為noFrictionMaterial。為了將滑塊與機器人的其餘部分牢固地鏈接在一起，我們使用[菜單欄-&gt;添加-&gt;力傳感器]添加了力傳感器對象。我們將其重命名為bubbleRob_connection並將其上移0.05。我們將滑塊連接到力傳感器，然後復制兩個對象，切換回場景1並粘貼它們。然後，我們將力傳感器沿絕對X軸移動-0.07，然後將其安裝到機器人主體上。如果現在運行仿真，我們會注意到滑塊相對於機器人主體略微移動：這是因為兩個對象（即bubbleRob_slider和bubbleRob）彼此碰撞。為了避免在動力學模擬過程中產生奇怪的影響，我們必須通知CoppeliaSim兩個對像不會相互碰撞，我們可以通過以下方式進行此操作：在形狀動力學屬性中，對於bubbleRob_slider，我們將本地可響應蒙版設置為00001111，對於bubbleRob，我們將本地可響應掩碼設置為11110000。如果再次運行仿真，我們會注意到兩個對像不再相互干擾。這就是我們現在擁有的：</p>
<p><img alt="" height="391" src="/images/04.jpg" width="493"/></p>
<p>[Proximity sensor, motors, wheels and slider]</p>
<p>We run the simulation again and notice that BubbleRob slightly moves, even with locked motor. We also try to run the simulation with different physics engines: the result will be different. Stability of dynamic simulations is tightly linked to masses and inertias of the involved non-static shapes. For an explanation of this effect, make sure to carefully read this and that sections. We now try to correct for that undesired effect. We select the two wheels and the slider, and in the shape dynamics dialog we click three times M=M*2 (for selection). The effect is that all selected shapes will have their masses multiplied by 8. We do the same with the inertias of the 3 selected shapes, then run the simulation again: stability has improved. In the joint dynamics dialog, we set the Target velocity to 50 for both motors. We run the simulation: BubbleRob now moves forward and eventually falls off the floor. We reset the Target velocity item to zero for both motors.</p>
<p>我們再次運行仿真，發現即使在電機鎖定的情況下，BubbleRob也會輕微移動。我們還嘗試使用不同的物理引擎運行仿真：結果將有所不同。動態仿真的穩定性與所涉及的非靜態形狀的質量和慣性緊密相關。有關此效果的說明，請務必仔細閱讀本節和該節。現在，我們嘗試糾正這種不良影響。我們選擇兩個輪子和滑塊，然後在“形狀動力學”對話框中單擊3次M = M * 2（用於選擇）。效果是所有選定形狀的質量都將乘以8。我們對3個選定形狀的慣性進行相同的操作，然後再次運行仿真：穩定性得到了改善。在關節動力學對話框中，我們將兩個電機的目標速度都設置為50。我們運行模擬：BubbleRob現在向前移動並最終掉落在地板上。我們將兩個電機的目標速度項都重置為零。</p>
<p>The object bubbleRob is at the base of all objects that will later form the BubbleRob model. We will define the model a little bit later. In the mean time, we want to define a collection of objects that represent BubbleRob. For that we define a collection object. We click [Menu bar --&gt; Tools --&gt; Collections] to open the collection dialog. Alternatively we can also open the dialog by clicking the appropriate toolbar button:</p>
<p>對象bubbleRob是所有對象的基礎，所有對象隨後將形成BubbleRob模型。我們將在稍後定義模型。同時，我們要定義代表BubbleRob的對象的集合。為此，我們定義了一個收集對象。我們單擊[Menu bar --&gt; Tools --&gt; Collections]以打開集合對話框。或者，我們也可以通過單擊相應的工具欄按鈕來打開對話框：<img alt="" height="40" src="/images/001.jpg" width="46"/></p>
<p>In the collection dialog, we click Add new collection. A new collection object appears in the list just below. For now the newly added collection is still empty (not defined). While the new collection item is selected in the list, select bubbleRob in the scene hierarchy, and then click Add in the collection dialog. Our collection is now defined as containing all objects of the hierarchy tree starting at the bubbleRob object (the collection's composition is displayed in the Composing elements and attributes section). To edit the collection name, we double-click it, and rename it to bubbleRob_collection. We close the collection dialog.</p>
<p>在集合對話框中，單擊添加新集合。一個新的集合對像出現在下面的列表中。目前，新添加的集合仍為空（未定義）。在列表中選擇新的收藏項時，在場景層次中選擇bubbleRob，然後在收藏對話框中單擊“添加”。現在，我們的集合被定義為包含層次結構樹的所有對象（從bubbleRob對像開始）（集合的組成顯示在“組成元素和屬性”部分中）。要編輯集合名稱，請雙擊它，然後將其重命名為bubbleRob_collection。我們關閉收集對話框。</p>
<p>At this stage we want to be able to track the minimum distance between BubbleRob and any other object. For that, we open the distance dialog with [Menu bar --&gt; Tools --&gt; Calculation module properties]. Alternatively we can also open the calculation module properties dialog with the appropriate toolbar button:</p>
<p>在此階段，我們希望能夠跟踪BubbleRob與任何其他對象之間的最小距離。為此，我們使用[菜單欄-&gt;工具-&gt;計算模塊屬性]打開距離對話框。或者，我們也可以使用相應的工具欄按鈕打開計算模塊屬性對話框：<img alt="" height="44" src="/images/002.jpg" width="46"/></p>
<p>In the distance dialog, we click Add new distance object and select a distance pair: [collection] bubbleRob_collection - all other measurable objects in the scene. This just added a distance object that will measure the smallest distance between collection bubbleRob_collection (i.e. any measurable object in that collection) and any other measurable object in the scene. We rename the distance object to bubbleRob_distance with a double-click in its name. We close the distance dialog. When we now run the simulation, we won't see any difference, since the distance object will try to measure (and display) the smallest distance segment between BubbleRob and any other measurable object in the scene. The problem is that at this stage there is no other measurable object in the scene (the shape defining the floor has its measurable property turned off by default). At a later stage in this tutorial, we will add obstacles to our scene.</p>
<p>在距離對話框中，單擊“添加新距離對象”並選擇一個距離對：[collection] bubbleRob_collection-場景中所有其他可測量對象。這只是添加了一個距離對象，該距離對象將測量集合bubbleRob_collection（即該集合中的任何可測量對象）與場景中任何其他可測量對象之間的最小距離。我們通過雙擊其名稱將距離對象重命名為bubbleRob_distance。我們關閉距離對話框。現在，當我們運行模擬時，我們不會看到任何區別，因為距離對象將嘗試測量（並顯示）BubbleRob與場景中任何其他可測量對象之間的最小距離段。問題在於，在此階段，場景中沒有其他可測量的對象（定義地板的形狀默認情況下已禁用其可測量的屬性）。在本教程的後續階段，我們將為場景添加障礙。</p>
<p>Next we are going to add a graph object to BubbleRob in order to display above smallest distance, but also BubbleRob's trajectory over time. We click [Menu bar --&gt; Add --&gt; Graph] and rename it to bubbleRob_graph. We attach the graph to bubbleRob, and set the graph's absolute coordinates to (0,0,0.005). Now we open the graph properties dialog by double-clicking its icon in the scene hierarchy. We uncheck Display XYZ-planes, then click Add new data stream to record and select Object: absolute x-position for the Data stream type, and bubbleRob_graph for the Object / item to record. An item has appeared in the Data stream recording list. That item is a data stream of bubbleRob_graph's absolute x-coordinate (i.e. the bubbleRobGraph's object absolute x position will be recorded). Now we also want to record the y and z positions: we add those data streams in a similar way as above. We now have 3 data streams that represent BubbleRob's x-, y- and z-trajectories. We are going to add one more data stream so that we are able to track the minimum distance between our robot and its environment: we click Add new data stream to record and select Distance: segment length for the Data stream type, and bubbleRob_distance for the Object / item to record. In the Data stream recording list, we now rename Data to bubbleRob_x_pos, Data0 to bubbleRob_y_pos, Data1 to bubbleRob_z_pos, and Data2 to bubbleRob_obstacle_dist.</p>
<p>接下來，我們將向BubbleRob添加一個圖形對象，以顯示最小距離以上的距離，同時還顯示BubbleRob隨時間的軌跡。我們單擊[Menu bar --&gt; Add --&gt; Graph]，並將其重命名為bubbleRob_graph。我們將圖形附加到bubbleRob，並將圖形的絕對坐標設置為（0,0,0.005）。現在，通過在場景層次結構中雙擊其圖標來打開圖形屬性對話框。我們取消選中“顯示XYZ平面”，然後單擊“添加新數據流以進行記錄”，然後選擇“對象：數據流類型的絕對x位置”，並選擇“ bubbleRob_graph”作為要記錄的對象/項目。數據流記錄列表中出現了一個項目。該項目是bubbleRob_graph的絕對x坐標的數據流（即，將記錄bubbleRobGraph的對象的絕對x位置）。現在，我們還想記錄y和z位置：我們以與上述類似的方式添加這些數據流。現在，我們有3個數據流，分別表示BubbleRob的x，y和z軌跡。我們將再添加一個數據流，以便能夠跟踪機器人與其環境之間的最小距離：單擊添加新數據流以進行記錄，然後選擇“距離：數據流類型的段長度”和“氣泡Rob_distance”作為要記錄的對象/項目。在數據流記錄列表中，我們現在將Data重命名為bubbleRob_x_pos，將Data0重命名為bubbleRob_y_pos，將Data1重命名為bubbleRob_z_pos，將Data2重命名為bubbleRob_obstacle_dist。</p>
<p>We select bubbleRob_x_pos in the Data Stream recording list and in the Time graph properties section, uncheck Visible. We do the same for bubbleRob_y_pos and bubbleRob_z_pos. By doing so, only the bubbleRob_obstacle_dist data stream will be visible in a time graph. Following is what we should have:</p>
<p>我們在“數據流”記錄列表中和“時間圖屬性”部分中選擇bubbleRob_x_pos，取消選中“可見”。我們對bubbleRob_y_pos和bubbleRob_z_pos都執行相同的操作。這樣，在時間圖中只能看到bubbleRob_obstacle_dist數據流。以下是我們應該擁有的：</p>
<p><img alt="" height="448" src="/images/05.jpg" width="273"/></p>
<p>[Graph properties]</p>
<p>Next we will set-up a 3D curve that displays BubbleRob's trajectory: we click Edit 3D curves to open the XY graph and 3D curve dialog, then click Add new curve. In the dialog that pops open, we select bubbleRob_x_pos for the X-value item, bubbleRob_y_pos for the Y-value item and bubbleRob_z_pos for the Z-value item. We rename the newly added curve from Curve to bubbleRob_path. Finally, we check the Relative to world item and set Curve width to 4:</p>
<p>接下來，我們將建立一個顯示BubbleRob軌蹟的3D曲線：單擊“編輯3D曲線”以打開XY圖形和3D曲線對話框，然後單擊“添加新曲線”。在彈出的對話框中，我們為X值項目選擇bubbleRob_x_pos，為Y值項目選擇bubbleRob_y_pos，為Z值項目選擇bubbleRob_z_pos。我們將新添加的曲線從Curve重命名為bubbleRob_path。最後，我們檢查“相對於世界”項目並將“曲線寬度”設置為4：</p>
<p><img alt="" height="291" src="/images/06.jpg" width="320"/></p>
<p>[3D curve properties]</p>
<p>We close all dialogs related to graphs. Now we set one motor target velocity to 50, run the simulation, and will see BubbleRob's trajectory displayed in the scene. We then stop the simulation and reset the motor target velocity to zero.</p>
<p>我們關閉與圖有關的所有對話框。現在我們將一個電機目標速度設置為50，運行模擬，然後將看到BubbleRob的軌跡顯示在場景中。然後，我們停止仿真並將電動機目標速度重置為零。</p>
<p>We add a pure primitive cylinder with following dimensions: (0.1, 0.1, 0.2). We want this cylinder to be static (i.e. not influenced by gravity or collisions) but still exerting some collision responses on non-static respondable shapes. For this, we disable Body is dynamic in the shape dynamics properties. We also want our cylinder to be Collidable, Measurable, Renderable and Detectable. We do this in the object common properties. Now, while the cylinder is still selected, we click the object translation toolbar button:</p>
<p>我們添加具有以下尺寸的純原始圓柱體：（0.1，0.1，0.2）。我們希望此圓柱體是靜態的（即不受重力或碰撞的影響），但仍會對非靜態的可響應形狀施加一些碰撞響應。為此，我們在形狀動力學屬性中禁用“主體是動態的”。我們還希望圓柱體是可碰撞的，可測量的，可渲染的和可檢測的。我們在對象的公共屬性中執行此操作。現在，在仍選擇圓柱體的情況下，我們單擊對象平移工具欄按鈕：<img alt="" height="35" src="/images/003.jpg" width="36"/></p>
<p>Now we can drag any point in the scene: the cylinder will follow the movement while always being constrained to keep the same Z-coordinate. We copy and paste the cylinder a few times, and move them to positions around BubbleRob (it is most convenient to perform that while looking at the scene from the top). During object shifting, holding down the shift key allows to perform smaller shift steps. Holding down the ctrl key allows to move in an orthogonal direction to the regular direction(s). When done, select the camera pan toolbar button again:</p>
<p>現在我們可以拖動場景中的任何點：圓柱體將跟隨運動，同時始終受約束以保持相同的Z坐標。我們複製並粘貼圓柱幾次，然後將它們移動到BubbleRob周圍的位置（從頂部查看場景時執行該操作最方便）。在對象移動期間，按住Shift鍵可以執行較小的移動步驟。按住ctrl鍵可以在與常規方向正交的方向上移動。完成後，再次選擇相機平移工具欄按鈕：<img alt="" height="38" src="/images/004.jpg" width="37"/></p>
<p>We set a target velocity of 50 for the left motor and run the simulation: the graph view now displays the distance to the closest obstacle and the distance segment is visible in the scene too. We stop the simulation and reset the target velocity to zero.</p>
<p>我們將左馬達的目標速度設置為50並運行模擬：現在，圖形視圖顯示了到最近障礙物的距離，並且該距離段在場景中也可見。我們停止模擬並將目標速度重置為零。</p>
<p>We now need to finish BubbleRob as a model definition. We select the model base (i.e. object bubbleRob) then check items Object is model base and Object/model can transfer or accept DNA in the object common properties: there is now a stippled bounding box that encompasses all objects in the model hierarchy. We select the two joints, the proximity sensor and the graph, then enable item Don't show as inside model selection and click Apply to selection, in the same dialog: the model bounding box now ignores the two joints and the proximity sensor. Still in the same dialog, we disable camera visibility layer 2, and enable camera visibility layer 10 for the two joints and the force sensor: this effectively hides the two joints and the force sensor, since layers 9-16 are disabled by default. At any time we can modify the visibility layers for the whole scene. To finish the model definition, we select the vision sensor, the two wheels, the slider, and the graph, then enable item Select base of model instead: if we now try to select an object in our model in the scene, the whole model will be selected instead, which is a convenient way to handle and manipulate the whole model as a single object. Additionally, this protects the model against inadvertant modification. Individual objects in the model can still be selected in the scene by click-selecting them with control-shift, or normally selecting them in the scene hierarchy. We finally collapse the model tree in the scene hierarchy. This is what we have:</p>
<p>現在，我們需要完成BubbleRob作為模型定義。我們選擇模型基礎（即對象bubbleRob），然後選中``對像是模型基礎''，然後選擇``對象/模型可以轉移或接受對象共同屬性中的DNA''：現在有一個點畫的邊界框包含模型層次結構中的所有對象。我們選擇兩個關節，即接近傳感器和圖形，然後啟用項目“不顯示為內部模型選擇”，然後在同一對話框中單擊“應用於選擇”：模型邊界框現在將忽略兩個關節和接近傳感器。仍在同一對話框中，我們禁用攝像機可見性層2，並為兩個關節和力傳感器啟用攝像機可見性層10：這有效地隱藏了兩個關節和力傳感器，因為默認情況下禁用第9-16層。我們可以隨時修改整個場景的可見性層。要完成模型定義，我們選擇視覺傳感器，兩個輪子，滑塊和圖形，然後啟用“選擇模型基礎”選項：如果現在嘗試在場景中選擇模型中的對象，則整個模型而是選擇，這是一種將單個模型處理和操縱整個模型的便捷方法。此外，這可以防止模型受到意外修改。仍然可以通過在按住Shift的同時單擊選擇對像或在場景層次結構中正常選擇它們，來在場景中選擇模型中的單個對象。最後，我們將模型樹折疊到場景層次中。這就是我們所擁有的：</p>
<p><img alt="" height="339" src="/images/07.jpg" width="425"/></p>
<p>[BubbleRob model definition]</p>
<p>Next we will add a vision sensor, at the same position and orientation as BubbleRob's proximity sensor. We open the model hierarchy again, then click [Menu bar --&gt; Add --&gt; Vision sensor --&gt; Perspective type], then attach the vision sensor to the proximity sensor, and set the local position and orientation of the vision sensor to (0,0,0). We also make sure the vision sensor is not not visible, not part of the model bounding box, and that if clicked, the model will be selected instead. In order to customize the vision sensor, we open its properties dialog. We set the Far clipping plane item to 1, and the Resolution x and Resolution y items to 256 and 256. We add a floating view to the scene, and over the newly added floating view, right-click [Popup menu --&gt; View --&gt; Associate view with selected vision sensor] (we make sure the vision sensor is selected during that process).</p>
<p>接下來，我們將在與BubbleRob接近傳感器相同的位置和方向上添加視覺傳感器。我們再次打開模型層次結構，然後單擊[Menu bar --&gt; Add --&gt; Vision sensor --&gt; Perspective type]，然後將視覺傳感器連接到接近傳感器，並將視覺傳感器的本地位置和方向設置為（0,0,0）。我們還確保視覺傳感器不可見，不是模型邊界框的一部分，並且如果單擊該模型，則會選擇模型。為了自定義視覺傳感器，我們打開其屬性對話框。將“遠裁剪平面”項設置為1，將“分辨率x”和“分辨率y”項設置為256和256。向場景中添加一個浮動視圖，並在新添加的浮動視圖上，右鍵單擊[Popup menu --&gt; View --&gt; Associate view with selected vision sensor]（我們確保在該過程中選擇了視覺傳感器）。</p>
<p>We attach a non-threaded child script to the vision sensor by clicking [Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]. We double-click the little icon that appeared next to the vision sensor in the scene hierarchy: this opens the child script that we just added. We copy and paste following code into the script editor, then close it:</p>
<p>通過單擊[Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]，將非線程子腳本附加到視覺傳感器。我們雙擊場景層次結構中視覺傳感器旁邊出現的小圖標：這將打開我們剛剛添加的子腳本。我們將以下代碼複製並粘貼到腳本編輯器中，然後將其關閉：</p>
<p><img alt="" height="73" src="/images/08.jpg" width="504"/></p>
<p>To be able to see the vision sensor's image, we start the simulation, then stop it again.</p>
<p>為了能夠看到視覺傳感器的圖像，我們開始模擬，然後再次停止。</p>
<p>The last thing that we need for our scene is a small child script that will control BubbleRob's behavior. We select bubbleRob and click [Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]. We double-click the script icon that appeared next to bubbleRob's name in the scene hierarchy and copy and paste following code into the script editor, then close it:</p>
<p>我們場景所需的最後一件事是一個小的子腳本，它將控制BubbleRob的行為。我們選擇bubbleRob並單擊[Menu bar --&gt; Add --&gt; Associated child script --&gt; Non threaded]。我們雙擊場景層次結構中bubbleRob名稱旁邊顯示的腳本圖標，然後將以下代碼複製並粘貼到腳本編輯器中，然後將其關閉：</p>
<p><img alt="" height="340" src="/images/09.jpg" width="514"/></p>
<p>We run the simulation. BubbleRob now moves forward while trying to avoid obstacles (in a very basic fashion). While the simulation is still running, change BubbleRob's velocity, and copy/paste it a few times. Also try to scale a few of them while the simulation is still running. Be aware that the minimum distance calculation functionality might be heavily slowing down the simulation, depending on the environment. You can turn that functionality on and off in the distance dialog, by checking / unchecking the Enable all distance calculations item.</p>
<p>我們運行模擬。 BubbleRob現在在嘗試避開障礙物的同時向前移動（以非常基本的方式）。在模擬仍在運行時，更改BubbleRob的速度，然後將其複制/粘貼幾次。在模擬仍在運行時，也嘗試擴展其中的一些。請注意，根據環境的不同，最小距離計算功能可能會嚴重降低仿真速度。您可以通過選中/取消選中“啟用所有距離計算”項來在“距離”對話框中打開和關閉該功能。</p>
<p>Using a script to control a robot or model is only one way of doing. CoppeliaSim offers many different ways (also combined), have a look at the external controller tutorial.</p>
<p>使用腳本控制機器人或模型只是一種方法。 CoppeliaSim提供了許多不同的方法（也可以結合使用），請參閱外部控制器教程。</p>
<h2>Week 6~9</h2>
<p>Week6</p>
<p>進行小組分工<br/><span>topic0:</span><br/>40723237<br/>40723221<br/>40723222<br/>40723228<br/>40723243<br/>40723244<br/>40723236<br/>40623117</p>
<p><span>topic1:</span><br/>40723221<br/>40723222<br/>40623252<br/>40523253<br/>40723249<br/>40732331<br/>40723240<br/>40723237</p>
<p>Week7</p>
<p>進行翻譯</p>
<p><span style="font-weight: 400;">DesignCollaborationBetterProducts.txt -- Printed on 2/29/2020, 4:04:22 PM -- Page 1</span></p>
<p><span style="font-weight: 400;">  設計協調更好的產品.txt -- 引印於2/29/2020,4:04:22 晚上 -- 第一頁</span><span style="font-weight: 400;"><br/></span><span style="font-weight: 400;">Create a Better Product With Design Collaboration — Mindset, Tools, Process</span><span style="font-weight: 400;"><br/></span><span style="font-weight: 400;">  透過設計協調創作更好的場品 — 心態、工具、過程</span><span style="font-weight: 400;"><br/></span><span style="font-weight: 400;">Shaun Moynihan</span></p>
<p><span style="font-weight: 400;">Jul 10, 2019</span></p>
<p><span style="font-weight: 400;">2019年 7月 10 日 </span></p>
<p></p>
<p><span style="font-weight: 400;">Digital products are more complex today than ever before. Creating them requires multiple team members, each with their own set of skills and expertise. At Savvy, for example, our customers work closely with: a product manager, UX designer, visual designer, developer(s), content strategist, and a growth specialist.</span></p>
<p><span style="font-weight: 400;">現今的數位產品比以往都還要複雜。創建他們需要更多的團隊。每位成員都需要擁有自己的技藝與專業知識。例如Savvy，我們的顧客。需要與產品經理、UX設計師、視覺設計師、開發人員、內容策略師還有增長專家密切配合。</span></p>
<p></p>
<p><span style="font-weight: 400;">We use design collaboration to handle this complexity. Done right, design collaboration empowers each of those experts with the mindset, process, and tools to come together and build a better product faster.</span></p>
<p><span style="font-weight: 400;">我們藉由設計協同來處理這種複雜性。正確的設計協同可以讓每一位專家擁有思維、流程和工具來快速的建立更好的產品。</span></p>
<p></p>
<p><span style="font-weight: 400;">We wrote this resource to help other app creators adopt a collaboration culture and process. Read on to learn why design collaboration is important for creating compelling products and experiences. We'll also dive into the elements of a design collaboration mindset and culture, tools for effective design collaboration, and a real-world example of design collaboration at work.</span></p>
<p><span style="font-weight: 400;">我們撰寫這篇資源是為了幫助其他APP創作者採用文化偕同和流程。深入閱讀了解為何設計協同對於創作引人注目的產品和體驗來說非常重要</span></p>
<p></p>
<p><span style="font-weight: 400;">What is "Design" Collaboration?</span></p>
<p><span style="font-weight: 400;">什麼是”設計”協同?</span></p>
<p></p>
<p><span style="font-weight: 400;">Before we jump into it, we need to get on the same page about what design collaboration is... and is not. At its simplest, design collaboration is collaboration in a design-first environment. But, because of the nature of design, especially the design we do at Savvy, design collaboration tends to go beyond what people normally think of as collaboration.</span></p>
<p><span style="font-weight: 400;">在直接跳入主題前，我們需要了解什麼是設計協同…什麼不是。簡單來說，設計協同就是在以設計為主的環境中進行協同合作。但是，因為設計的本質，特別是在與Savvy合作的設計之中，設計協同往往會超出人們一般認為的合作範圍。</span></p>
<p></p>
<p><span style="font-weight: 400;">While collaboration is generally defined as two or more people working together on the same task towards a common goal, design collaboration involves much more.</span></p>
<p><span style="font-weight: 400;">協同一般被定義為兩個或更多的人一起為同樣的目標工作，然而設計協同所涉及的東西卻更多。</span></p>
<p></p>
<p><span style="font-weight: 400;">Design collaboration includes more people with different skillsets, tougher challenges, and bigger goals with farther-reaching impacts.</span></p>
<p><span style="font-weight: 400;">設計協同包羅了更多具有不同技能的人、更艱困的挑戰、更大的目標並產生更深遠的影響</span></p>
<p></p>
<p><span style="font-weight: 400;">You might think of collaboration as two people hanging a piece of art. It simply requires communication, teamwork, and four hands. Design collaboration is when a team of curators carefully design a visitor's experience. They select the art, choose where and how to hang it, which room it lives in (and the room's lighting, furniture), even the preceding rooms and the building as a whole.</span></p>
<p><span style="font-weight: 400;">你可能會認為協同就是兩個人懸掛一件藝術品，只需要溝通、團隊工作、和四隻手而已。設計合作是指由策劃團隊精心為參觀者設計的體驗，他們挑取藝術品並挑選掛在什麼地方、如何掛、掛在哪個房間(以及房間的燈光和家具) ，甚至是前一個房間和整棟建築物。</span></p>
<p></p>
<p><span style="font-weight: 400;">Why Design Collaboration is Important</span></p>
<p><span style="font-weight: 400;">為什麼設計協同是重要的。</span></p>
<p></p>
<p><span style="font-weight: 400;">You can design a product without collaboration, but it takes a collaborative design process to make that product great. That's why design collaboration is so fundamental.</span></p>
<p><span style="font-weight: 400;">你可以在沒有協同的情況下設計出一件產品，但透過一個合作的設計過程可以讓產品變的更加優秀，這就是為什麼設計協同是如此的重要。</span></p>
<p></p>
<p><span style="font-weight: 400;">We don't just build apps for our customers. Savvy builds multi-platform experiences, complex internal systems, and in some cases, entire brands and businesses. To do so, we leverage expertise across several core disciplines: strategy, design, development, and growth. Each project involves many people, each with their own skillsets and specialties.</span></p>
<p><span style="font-weight: 400;">我們並不只是為顧客構建應用程式，Savvy構建了多平台體驗、複雜的內部系統，並且在某些情況下，還可以構建整個品牌與業務，為此我們在戰略、設計、開發和成長等領域利用核心專業技術，每個項目都有許多人參加，每個人都有自己的技藝與專長。</span></p>
<p></p>
<p><span style="font-weight: 400;">Design collaboration puts those minds together, combining their separate, specialized expertise to create solutions that tackle all aspects of a shared goal. Instead of coming at a problem from one angle, design collaboration places that problem in front of all experts, forcing them to consider new perspectives and possibilities.</span></p>
<p><span style="font-weight: 400;">設計協同將這些人的思想概念結合在一起，將他們獨自的專業知識結合起來，創造出能夠解決共同目標所有方面問題的方案。設計協同不是從一個角度來解決一個問題，而是將所有問題放在專家面前，迫使他們考慮新的觀點與可能性。</span></p>
<p></p>
<p><span style="font-weight: 400;">For example, we involve our developers early on in the design process to make sure we're accounting for technical opportunities and limitations as soon as possible. This allows us to take advantage of and push our technical capabilities while eliminating costly roadblocks further in the process. It also limits how much a single person can work in a silo, keeping the work in the open and the emphasis on the user needs and product goals.</span></p>
<p><span style="font-weight: 400;">例如，我們在早期的設計過程就讓開翻人員參予進來，確保盡快解決技術問題與侷限性。這使我們能夠利用在推動技術能力過程時，進一步消除昂貴的路障。這也同時限制一個人在筒倉的工作量，保持工廠的開放性，將重點放在用戶需求與產品目標上。</span></p>
<p></p>
<p><span style="font-weight: 400;">Cultivating a Design Collaboration Mindset</span></p>
<p><span style="font-weight: 400;">培養設計協同的心態</span></p>
<p></p>
<p><span style="font-weight: 400;">The right mindset goes a long way in establishing effective collaboration in the design process. It lays the guidelines for who collaborates, how, and to what end.</span></p>
<p><span style="font-weight: 400;">正確的心態能幫助在設計過程中建立有效的合作關係，它為由誰來合作、如何合作以及合作的目的制定了準則。</span></p>
<p></p>
<p><span style="font-weight: 400;">COLLABORATION IS FOR EVERYONE</span></p>
<p><span style="font-weight: 400;">協同是人人都可以的。</span></p>
<p></p>
<p><span style="font-weight: 400;">Designers sometimes think that people who are not designers are not qualified to give good feedback. But great design is more than visuals. It encompasses everything about a product, from its branding to its engineering to its growth.</span></p>
<p><span style="font-weight: 400;">設計師有時候會認為不是設計師的人是沒有資格給出好的反饋的。但是，好的設計是不僅僅有視覺效果而已的，它包含了一個產品的一切，從品牌到工程再到在到期發展的一切。</span></p>
<p></p>
<p><span style="font-weight: 400;">Design collaboration brings in many people, each with their own perspectives and strengths. It gives everyone a voice. These fresh perspectives give designers more information. Perspectives equip designers to make the right decisions on choices that have lasting impacts on other design, development, and marketing options down the road.</span></p>
<p><span style="font-weight: 400;">設計協同引進了許多人，每個人都有其自己的觀點與優勢，它使每個人都可以擁有發言權，這些創新的視角給了設計師更多的信息。觀點可以讓設計師能夠做出正確的決定，這些選擇會對以後的設計、開發與營銷產生持久的引響。</span></p>
<p></p>
<p><span style="font-weight: 400;">Collaboration with customers is as important as collaboration with other designers and team members. At Savvy, we keep our customer involved throughout the creation of their product. We take our time to explain options and have discussions with the customer to make sure we understand their thoughts.</span></p>
<p><span style="font-weight: 400;">與客戶的合作和與其他設計師、團隊成員的合作同樣重要。在與Savvy的合作中，我們讓客戶參予產品的製作過程，並花時間解釋所選方案，與客戶進行討論，以確保我們了解他們的想法。</span></p>
<p></p>
<p><span style="font-weight: 400;">This enables us to get buy-in from customers early on and work from clear beginnings and ends. Larger reveals aren't big surprises, and no one gets to the point where they're seeing work for the first time.</span></p>
<p><span style="font-weight: 400;">這樣一來，我們就可以確保客戶的買帳並使工作有始有終，較大的揭露並不是什麼太大的驚喜，沒有人會因為第一次看到工作而感到驚訝。</span></p>
<p></p>
<p><span style="font-weight: 400;">Customer collaboration means arriving at a more defined product sooner, without costly back-stepping and unnecessary meetings.</span></p>
<p><span style="font-weight: 400;">客戶的合作意味著更早產生一個確定的產品，避免了昂貴的迴避與不必要的會議。</span></p>
<p></p>
<p><span style="font-weight: 400;">It's easy to get caught up in your role and ignore the big picture. By involving more people earlier on, you're fostering closer connections with teammates and cultivating a shared responsibility and interest in the success of the product. You're creating a more open and transparent process, as well a more connected and invested team.</span></p>
<p><span style="font-weight: 400;">人們很容易沉浸在自己所扮演的角色中而忽略了大局關，透過讓更多的人在早期參與進來，就能將團隊成員之間的聯繫培養的更緊密，並培養出責任感與對產品是否能成功的興趣。你正在創造一個更開放、更透明的過程，以及一個更有聯繫和投入的團體。</span></p>
<p></p>
<p><span style="font-weight: 400;">COLLABORATION IS CONTEXTUAL</span></p>
<p><span style="font-weight: 400;">協同是有背景的</span></p>
<p></p>
<p><span style="font-weight: 400;">Customers come to us with complex challenges and goals. Not to mention, we continue to work with our customers for months, even years, and accumulate vast tomes of knowledge on past decisions, research, and other valuable context.</span></p>
<p><span style="font-weight: 400;">客戶帶著複雜的挑戰與目標來尋找我們。更別提我們會持續與客戶合作數月甚至數年，累積了大量的知識，包含過去的決策、研究等其他有價值的背景。</span></p>
<p></p>
<p><span style="font-weight: 400;">By adopting a context-first approach, you can make sure everyone is at the highest level of knowledge. This enables them to make the most informed decisions as they work on the product. To accomplish this, we keep everyone at Savvy updated on relevant information by bringing in all team members early, documenting and recording meetings, establishing some overlap, and treating the next team member in the process like a customer.</span></p>
<p><span style="font-weight: 400;">透過適者生存的方法，確保每個人都處於最高的知識水平。使他們能夠在開發產品的過程中能夠做出最明確的決定，為了能夠做到這一點，我們透過提前召集所有團隊成員，紀錄和紀錄會議的內容，建立一些重和點，並將下一個團隊成員視為顧客，讓Savvy團隊的每一個人都能及時了解相關資訊。</span></p>
<p></p>
<p><span style="font-weight: 400;">Context is just as important on a case-by-case collaborative basis. Follow these guidelines to keep context first in collaboration:</span></p>
<p><span style="font-weight: 400;">在個案合作的基礎上，情境同樣重要，遵循這些準則，在合作中要把情境放在首位。</span></p>
<p></p>
<p><span style="font-weight: 400;">Provide context before showing your work. Chances are if your work is on the screen while you're giving context, you've lost your audience's attention.</span></p>
<p><span style="font-weight: 400;">在顯示您的工作之前提供上下文。在提供背景信息的情況下，如果您的作品出現在屏幕上，那麼您可能會失去聽眾的注意力。</span></p>
<p></p>
<p><span style="font-weight: 400;">Describe the problem you're trying to solve or goal you're trying to achieve.</span></p>
<p><span style="font-weight: 400;">描述您要解決的問題或要達到的目標。</span></p>
<p><br/><br/></p>
<p><span style="font-weight: 400;">Present your work as it relates to the problem at hand. Explain your thinking and why you made certain decisions.</span></p>
<p><span style="font-weight: 400;">介紹與當前問題相關的工作。說明您的想法以及做出某些決定的原因。</span></p>
<p></p>
<p><span style="font-weight: 400;">Be specific about what you want feedback on.</span></p>
<p><span style="font-weight: 400;">請具體說明您要反饋的內容。</span></p>
<p></p>
<p><span style="font-weight: 400;">COLLABORATION IS OPEN, HONEST, AND FEARLESS</span></p>
<p><span style="font-weight: 400;">合作是開放，誠實和無畏的</span></p>
<p></p>
<p><span style="font-weight: 400;">It isn't easy to put your work (and yourself) out there. Emotions can get in the way of providing open and honest feedback, especially when you're worried about hurting the other person's feelings.</span></p>
<p><span style="font-weight: 400;">將您的工作（和您自己）放在那裡並不容易。情緒會阻礙您提供坦誠的反饋，尤其是當您擔心會傷害對方的感受時。</span></p>
<p></p>
<p><span style="font-weight: 400;">That doesn't mean there's no place for emotion in collaboration. How something makes you feel is important in design. We think of and create solutions for people... people who are emotional, and who use emotions in their decisions. Leaving emotion out of the conversation might short-change a potential idea or solution. At best, having only a pragmatic discussion around facts and data won't provide the full picture. At worst, it may be a red herring or provide a false narrative.</span></p>
<p><span style="font-weight: 400;">這並不意味著在協作中沒有情感的位置。在設計中，讓您感覺如何是很重要的。我們為人們思考並為他們創建解決方案，有情感並在決策中使用情感的人。在對話中留下的情感可能會縮短潛在的想法或解決方案。充其量，僅就事實和數據進行務實的討論將無法提供全面的信息。在最壞的情況下，它可能是掩人耳目或提供虛假的敘述。</span></p>
<p></p>
<p><span style="font-weight: 400;">At Savvy, we empower our team to be "fearless" about receiving feedback. This means letting go of any anxieties about being judged for what we create. It also means understanding that we are stronger together and stand a greater chance of creating something great. In being fearless, we better trust and empower each other to give honest and thoughtful feedback.</span></p>
<p><span style="font-weight: 400;">在與Savvy的合作中，我們使我們的團隊對收到反饋感到“無所畏懼”。這意味著放開對我們所創造的東西進行判斷不會感到任何焦慮。這也意味著我們在一起將會更加強大，更有機會創造偉大的事物。在無所畏懼的情況下，我們會更好地相互信任和相互賦予能力，以提供誠實和周到的反饋。</span></p>
<p></p>
<p><span style="font-weight: 400;">Our team also believes in being fearless about providing feedback. This means understanding the problem that needs solving as well as the customer's brand and goals. It also means asking lots of questions either to uncover relevant thoughts or to help guide decisions.</span></p>
<p><span style="font-weight: 400;">我們的團隊還信奉無所畏懼地提供反饋。這意味著能夠了解需要解決的問題以及客戶的品牌和目標。同時也意味著可以問很多問題，以發現相關的思想或幫助指導決策。</span></p>
<p></p>
<p><span style="font-weight: 400;">Try presenting feedback in an exploratory and guiding manner, with the intent of building up and improving the work rather than tearing it down.</span></p>
<p><span style="font-weight: 400;">嘗試以探索性和指導性的方式提出反饋意見，目的是建立和改進工作，而不是拆散工作。</span></p>
<p></p>
<p><span style="font-weight: 400;">Your feedback should be constructive. Instead of saying you don't like something, frame your feedback to point back to the problem you're trying to help solve. Provide actionable steps on improving the work or at the very least the reasoning behind your thinking. And don't forget to express what you like and why.</span></p>
<p><span style="font-weight: 400;">您的反饋意見應具有建設性。與其說您不喜歡某些東西，不如說出您的反饋意見以指出您要幫助解決的問題。提供可行的步驟來改進工作，或者至少提供您思考背後的理由。並且不要忘了表達您喜歡什麼以及為什麼。</span></p>
<p></p>
<p><span style="font-weight: 400;">COLLABORATION IS MORE THAN NEW IDEAS</span></p>
<p><span style="font-weight: 400;">合作不僅僅是新的想法</span></p>
<p></p>
<p><span style="font-weight: 400;">It's one thing to be open and accepting of collaborative feedback, another to parse those thoughts and use them as catalysts to spark your own. This is a more advanced skill that develops over time. One way to practice this is to become a better listener.</span></p>
<p><span style="font-weight: 400;">開放並接受協作反饋是一回事，解析這些想法並將其用來催生您自己的想法是另一回事。隨著時間的推移，這是一項更高級的技能。實踐方法將成為更好的聽眾。</span></p>
<p></p>
<p><span style="font-weight: 400;">Often, during a conversation with others, we think more about what we are going to say next rather than what others are saying. This impacts the feedback process, especially in design, because we often know what we want to say before hearing another opinion or solution.</span></p>
<p><span style="font-weight: 400;">通常，在與他人交談時，我們會更多地考慮接下來要說的內容，而不是別人在說什麼。這會影響反饋過程，尤其是在設計過程中，因為在聽到其他意見或解決方案之前，我們通常會知道我們要說的話。</span></p>
<p></p>
<p><span style="font-weight: 400;">When you choose to listen first and react second, it allows you to fully understand the feedback someone else is presenting and sets you up to go deeper — what is the perspective they're using and the place they're coming from? Chances are this is a perspective you didn't consider during the creation process. By listening to and understanding the context and reasoning behind the feedback you're receiving, you're opening yourself to more ways of looking at, thinking of, and experiencing your design. You can then test these new perspectives against the challenges, goals, and use cases you're designing for to see if they better suit the user.</span></p>
<p><span style="font-weight: 400;">當您選擇先聆聽然後再做出反應時，它可以讓您完全理解其他人的反饋，並讓您更深入地了解自己 — 他們使用的觀點是什麼以及來自何處？很有可能這是您在創建過程中未曾考慮過的觀點。通過聽取並理解收到反饋時背後的上下文和推理，您可以以更多的方式來審視，思考和體驗設計。然後，您可以針對要設計的挑戰，目標和用例來測試這些新觀點，以查看它們是否更適合用戶。</span></p>
<p></p>
<p><span style="font-weight: 400;">It's easier to be more receptive of feedback when all collaborators practice active listening. Ultimately, the skill of giving great feedback comes from learning how to receive it. As we make an effort to be better listeners, we also find ourselves becoming more humble and, in our opinion, better designers.</span></p>
<p><span style="font-weight: 400;">當所有協作者都在積極聆聽時，更容易接受反饋。最終，提供良好反饋的技能來自於學習如何獲得反饋。當我們努力成為更好的聽眾時，我們也發現自己變得更加謙虛，並認為我們是更好的設計師。</span></p>
<p></p>
<p><span style="font-weight: 400;">Finding and Using the Right Design Collaboration Tools</span></p>
<p><span style="font-weight: 400;">尋找和使用正確的設計協作工具</span></p>
<p></p>
<p><span style="font-weight: 400;">The right tools go a long way in reinforcing your team's design collaboration mindset. In this section, you'll learn what to look for in collaboration tools. We also recommend tools based on our own experiences.</span></p>
<p><span style="font-weight: 400;">正確的工具在增強團隊的設計協作思維方面大有幫助。在本節中，您將學習在協作工具中尋找什麼。我們還根據自己的經驗推薦工具。</span></p>
<p></p>
<p><span style="font-weight: 400;">SELECTING THE RIGHT TOOLS</span></p>
<p><span style="font-weight: 400;">選擇合適的工具</span></p>
<p></p>
<p><span style="font-weight: 400;">Effective collaboration tools remove all barriers for collaborators to quickly and easily access and interact with the work. This keeps the focus on giving feedback. They also allow others to collaborate on a design without destroying the original.</span></p>
<p><span style="font-weight: 400;">有效的協作工具消除了協作者想要快速輕鬆地訪問工作並與之交互時的所有障礙。這將重點放在提供反饋上。它們還允許其他人在不破壞原始設計的情況下進行協作。</span></p>
<p></p>
<p><span style="font-weight: 400;">In the past, we used relied on tools that provided basic versioning control instead of true collaborative features. For example, a designer would save a Sketch file and upload it to Dropbox. Another team member would then download it, work on it, and re-upload it. There was no easy way to make changes while the file was in another's hands. We tried something similar with Github, a tool that proved great for managing codebases, but not so much with iterative design work. Needless to say, these version control processes made our collaboration more time consuming, confusing, and very un-collaborative.</span></p>
<p><span style="font-weight: 400;">過去，我們依賴於提供基本版本控製而不是真正的協作功能的工具。例如，設計人員將保存一個Sketch文件並將其上傳到Dropbox。然後，另一個團隊成員下載它，進行處理，然後重新上傳。當文件在另一個人手中時，沒有辦法用簡單的方法來進行更改。我們使用Github嘗試了類似的方法，該工具被證明非常適合管理代碼庫，但對於反覆設計的工作卻沒有太多幫助。不用說，這些版本控製過程使我們的協作更加耗時，混亂並且非常不協作。</span></p>
<p></p>
<p><span style="font-weight: 400;">Now we choose from a variety of more advanced tools depending on the type of collaboration we want to achieve.</span></p>
<p><span style="font-weight: 400;">現在，我們根據要實現的協作類型從各種更高級的工具中進行選擇。</span></p>
<p></p>
<p><span style="font-weight: 400;">FIGMA</span></p>
<p><span style="font-weight: 400;">戰鬥機</span></p>
<p></p>
<p><span style="font-weight: 400;">This is a collaboration-first, shared workspace tool. Figma works well for having multiple people in same area of the design file. You can watch teammates design or work together on the same design in real time.</span></p>
<p><span style="font-weight: 400;">這是一個以協作為優先的共享工作區工具。 Figma非常適合在設計文件的同一區域中包含多個人。您可以時時觀看隊友的設計或在同一個設計上一起工作。</span></p>
<p></p>
<p><span style="font-weight: 400;">Benefits:</span></p>
<p><span style="font-weight: 400;">好處：</span></p>
<p></p>
<p><span style="font-weight: 400;">Figma reduces the ability for someone to work in a silo.</span></p>
<p><span style="font-weight: 400;">Figma降低了某人在筒倉中工作的能力。</span></p>
<p></p>
<p><span style="font-weight: 400;">There's no need to add unnecessary polish or create static deliverables to enable collaboration. So you don't need to change your workflow to show off a design.</span></p>
<p><span style="font-weight: 400;">無需添加不必要的修飾或創建可交付結果的靜態即可實現協作。因此，您無需更改工作流程即可展示設計。</span></p>
<p></p>
<p><span style="font-weight: 400;">It's easy to see and interact with the work in its native environment and apply tweaks at will.</span></p>
<p><span style="font-weight: 400;">可以輕鬆地在其本環境中查看並與之交互，並隨意進行調整。</span></p>
<p></p>
<p><span style="font-weight: 400;">When to use: Flow docs, high-fidelity wireframes, spur-of-the-moment collaboration, and walking customers through a series of screens to explain and get feedback on design direction.</span></p>
<p><span style="font-weight: 400;">使用時：流程文檔，高保真線框，即時協作，以及引導客戶瀏覽一系列屏幕，以解釋並獲得有關設計方向的反饋。</span></p>
<p></p>
<p><span style="font-weight: 400;">MARVEL</span></p>
<p><span style="font-weight: 400;">奇蹟</span></p>
<p></p>
<p><span style="font-weight: 400;">While Figma tends to feel more free-form and flexible, Marvel allows for a more standardized form of collaboration. It also makes it easy on our customers to collaborate with us.</span></p>
<p><span style="font-weight: 400;">雖然Figma傾向於自由和靈活，但Marvel允許採用更標準化的協作形式。這也使我們的客戶可以輕鬆地與我們合作。</span></p>
<p></p>
<p><span style="font-weight: 400;">Benefits:</span></p>
<p><span style="font-weight: 400;">好處：</span></p>
<p></p>
<p><span style="font-weight: 400;">Marvel is a cleaner, more formalized and focused space, great for collaborating with non-design team members.</span></p>
<p><span style="font-weight: 400;">Marvel是一個更簡潔、規範和專注的空間，非常適合與非設計團隊成員進行協作。</span></p>
<p></p>
<p><span style="font-weight: 400;">It removes all need for the customer to pay for an account or have a deep understanding of the tool to see the work.</span></p>
<p><span style="font-weight: 400;">它消除了客戶為帳戶付款或對工具進行深入了解的所有需求。</span></p>
<p></p>
<p><span style="font-weight: 400;">Customers can download screens and see them in action on a device environment via the Marvel app.</span></p>
<p><span style="font-weight: 400;">客戶可以下載屏幕，並通過Marvel應用程序在設備環境中查看它們的運行情況。</span></p>
<p></p>
<p><span style="font-weight: 400;">When to use: Presenting more finalized design work with customers and developers. (Learn about how Marvel compares with other prototyping tools.)</span></p>
<p><span style="font-weight: 400;">使用時：與客戶和開發人員一起呈現更多的最終設計工作。 （了解Marvel如何與其他原型工具進行比較。）</span></p>
<p></p>
<p><span style="font-weight: 400;">OTHER COLLABORATION TOOLS</span></p>
<p><span style="font-weight: 400;">其他合作工具</span></p>
<p></p>
<p><span style="font-weight: 400;">Zeplin is a useful hand-off tool that allows developers to dive into the nitty gritty specs of design work. (We talk more in-depth about Zeplin here.)</span></p>
<p><span style="font-weight: 400;">Zeplin是一個有用的傳遞工具，使開發人員可以深入研究設計工作的細節。 （我們在這裡更深入地討論Zeplin。）</span></p>
<p></p>
<p><span style="font-weight: 400;">Quip is a great platform for brainstorming and product/process documentation. We use it to record and organize all of the context and knowledge that team members need to know when working on a project. It's also useful for brainstorming new ideas that aren't visual-focused.</span></p>
<p><span style="font-weight: 400;">Quip是集思廣益在產品/流程文件的絕佳平台。我們使用它來記錄和組織團隊成員在項目上需要了解的所有環境和知識。對於集思廣益新思路而不是視覺關注的新想法也很有用。</span></p>
<p></p>
<p><span style="font-weight: 400;">Please note that there are many other tools out there that add similar benefits to collaboration as the ones listed above. This list represents the tools that have worked well for us in our day-to-day collaboration and is not indicative of all the options that might work well for your team.</span></p>
<p><span style="font-weight: 400;">請注意，還有許多其他工具可以為協作增加與上面類似的好處。此列表代表了在我們日常合作中對我們有效的工具，但並不表示所有可能對您的團隊有效的選項。</span></p>
<p></p>
<p><span style="font-weight: 400;">Savvy's Design Collaboration Process in Practice</span></p>
<p><span style="font-weight: 400;">精明的設計合作過程在實踐中</span></p>
<p></p>
<p><span style="font-weight: 400;">Now let's take the best practices and tools outlined above and show how they fit together in a real-life situation. We'll use the live drawing experience in the Press Play app to demonstrate the importance of design collaboration. This experience involved significant collaboration from a number of team members across disciplines, including a visual designer, UX designer, developer, product manager, and of course, the customer.</span></p>
<p><span style="font-weight: 400;">現在，讓我們採用上面概述的最佳實踐和工具，並展示它們如何在現實生活中融合在一起。我們將使用Press Play應用程序中的實際繪圖經驗來演示設計協作的重要性。這種經驗涉及多個學科領域的團隊成員之間的重大協作，其中包括視覺設計師，UX設計人員，開發人員，產品經理，當然還有客戶。</span></p>
<p></p>
<p><span style="font-weight: 400;">THE CONTEXT AND CHALLENGE</span></p>
<p><span style="font-weight: 400;">語境與挑戰</span></p>
<p></p>
<p><span style="font-weight: 400;">Press Play is a sweepstakes app that holds daily, weekly, and monthly drawings. Users earn tickets by watching ads and enter drawings by selecting five emojis. Winners are then rewarded based on how their choices match up with the drawing's randomly-selected emojis. This particular task had us creating a fun and exciting live experience for users awaiting the results of the live drawing.</span></p>
<p><span style="font-weight: 400;">Press Play是一個抽獎活動應用程序，可保存每日，每周和每月的圖紙。用戶通過觀看廣告賺取門票，並通過五個表情符號的選擇來輸入圖紙。然後，根據獲獎者的選擇與繪畫中隨機選擇的表情符號匹配的方式來獎勵獲獎者。這項特殊任務使我們為等待現場繪畫結果的用戶創造了一種有趣而激動人心的現場體驗。</span></p>
<p></p>
<p><span style="font-weight: 400;">It was important for us to create a game-like animation for this experience. We especially wanted to evoke a sense of playfulness and anticipation on the screen where users go to see how their chosen emojis match up with those from the sweepstakes drawing.</span></p>
<p><span style="font-weight: 400;">對於我們來說，為這種體驗創建類似遊戲的動畫非常重要。我們特別想在屏幕上喚起用戶的嬉戲感和期待感，讓用戶看到他們選擇的表情符號與抽獎活動圖上的表情符號相匹配。</span></p>
<p></p>
<p><span style="font-weight: 400;">That said, we needed to be mindful of the level of complexity an animation requires and its impact on the overall product's timeline and cost. Our goal was to push the level of fidelity within a reasonable time without significantly impacting the project's budget.</span></p>
<p><span style="font-weight: 400;">也就是說，我們需要注意動畫所需的複雜程度及其對整體產品時間表和成本的影響。我們的目標是在合理的時間內提高真實度，而又不顯著影響項目預算。</span></p>
<p></p>
<p><span style="font-weight: 400;">THE COLLABORATIVE PROCESS</span></p>
<p><span style="font-weight: 400;">合作過程</span></p>
<p></p>
<p><span style="font-weight: 400;">Stage 1: Wireframes and Brainstorming</span></p>
<p><span style="font-weight: 400;">階段1：線框和自由討論</span></p>
<p></p>
<p><span style="font-weight: 400;">First, a Savvy UX designer created Press Play's overall UX and wireframes, determining what screens were needed and the timing for each one. She also put together a rough concept (shown right) for the live drawing animation, expressing initial ideas based on customer's needs and the project's established UX.</span></p>
<p><span style="font-weight: 400;">首先，一位精明的UX設計師創建了Press Play的整體UX和線框，確定需要哪些屏幕以及每個屏幕的時間安排。她還為實時繪畫動畫整理了一個粗略的概念（如右方所示），根據客戶的需求和項目已建立的用戶體驗表達了初步的想法。</span></p>
<p></p>
<p><span style="font-weight: 400;">She presented the wireframes and the rough animation to the product manager and visual designer. Then all three met with the customer so everyone would hear the feedback directly.</span></p>
<p><span style="font-weight: 400;">她向產品經理和視覺設計師展示了線框和粗糙的動畫。然後這三個人都與客戶會面，因此每個人都可以直接聽到反饋。</span></p>
<p></p>
<p><span style="font-weight: 400;">Stage 2: Research and Context</span></p>
<p><span style="font-weight: 400;">第二階段：研究與背景</span></p>
<p></p>
<p><span style="font-weight: 400;">The Savvy visual designer tasked with creating the actual live drawing animation came in with fresh eyes and without much prior knowledge of the Press Play product. To get up to speed, he talked in depth with the UX designer and product manager. He also dedicated additional research time to understand the overall product goals, challenges, and to familiarize himself with the work to date. As mentioned earlier, he was part of the wireframe presentation and present for the customer's feedback.</span></p>
<p><span style="font-weight: 400;">精明的視覺設計師負責創建實際的繪畫動畫，他們的眼睛新鮮，而且對Press Play產品沒有太多的了解。為了加快速度，他與UX設計師和產品經理進行了深入交流。他還花費額外的研究時間來了解總體產品目標，挑戰並熟悉迄今為止的工作。如前所述，他展示線框演示的一部分，並向客戶提出反饋。</span></p>
<p></p>
<p><span style="font-weight: 400;">With that context, he conducted some additional research more directly related to the task at hand. In doing so, he made sure he understood the live drawing experience requirements, goals, and challenges. He looked at other apps with similar experiences and fidelity and referenced the rough animation to know what exactly the final animation needed to show (in this case, the winning emojis and the user's emoji selections). Before getting too tied to a solution, he met with a Savvy iOS developer to understand technical constraints and considerations.</span></p>
<p><span style="font-weight: 400;">在這種情況下，他進行了一些與手頭任務直接相關的其他研究。通過這樣做，他確保自己了解現場繪畫體驗的要求、目標和挑戰。他查看了具有類似體驗和真實度的其他應用，並參考了粗糙的動畫以了解最終動畫到底需要顯示什麼（在這種情況下，是獲勝的表情符號和用戶的表情符號選擇）。在過於依賴解決方案之前，他會見了一位精明的iOS開發人員，以了解技術限制和注意事項。</span></p>
<p></p>
<p><span style="font-weight: 400;">Our visual designer and UX designer then brainstormed what was important for the visuals. They agreed that there needed to be a slow reveal to build up suspense/anticipation for the user</span></p>
<p><span style="font-weight: 400;">然後，我們的視覺設計師和UX設計師集思廣益，視覺效果非常重要。他們一致認為，需要慢慢進行透露，以便為用戶建立懸念/期待</span></p>
<p></p>
<p><span style="font-weight: 400;">Stage 3: Iteration and Feedback</span></p>
<p><span style="font-weight: 400;">階段3：迭代和反饋</span></p>
<p></p>
<p><span style="font-weight: 400;">As our visual designer worked through a number of different directions he tapped the UX designer to chat through his progress and designs in Figma. By talking through the work they spurred more ideas and iterations while making sure they were staying true to customer expectations. With more solid options at hand, he met once again with the iOS developer to make sure everything was in line from a technical perspective.</span></p>
<p><span style="font-weight: 400;">當我們的視覺設計師沿多個不同方向工作時，他邀請了UX設計師來聊聊他在Figma中的進度和設計。通過討論工作，他們激發了更多的想法和迭代，同時確保它們符合客戶的期望。有了更多可靠的選擇，他再次與iOS開發人員會面，以確保從技術角度來看一切都符合要求。</span></p>
<p></p>
<p><span style="font-weight: 400;">Stage 4: Customer Feedback and Development</span></p>
<p><span style="font-weight: 400;">階段4：客戶的反饋和發展</span></p>
<p></p>
<p><span style="font-weight: 400;">When we landed on several, more finalized versions of the experience, the visual designer walked through them with the customer using Figma. The product manager and UX designer for Press Play provided feedback and guidance as well.</span></p>
<p><span style="font-weight: 400;">當我們找到了幾種最終確定的體驗版本時，視覺設計師使用Figma與客戶一起瀏覽了它們。 Press Play的產品經理和UX設計師也提供了反饋和指導。</span></p>
<p></p>
<p><span style="font-weight: 400;">Once they all learned what piqued the customer's interest, the visual designer set off to maximize the visuals and make them ready for development. He continued to work with the iOS developer to get the most out of the concept on a technical level.</span></p>
<p><span style="font-weight: 400;">一旦他們都了解了會引起客戶興趣的東西，視覺設計師便開始著手讓視覺效果最大化，並為開發做好準備。他繼續與iOS開發人員合作，以在技術層面上充分利用該概念。</span></p>
<p></p>
<p><span style="font-weight: 400;">THE END RESULT</span></p>
<p><span style="font-weight: 400;">最終結果</span></p>
<p></p>
<p><span style="font-weight: 400;">Press Play's live drawing animation is an example of design collaboration at work; a team of cross-discipline experts working together to solve a design and development challenge with bigger implications. Without design collaboration, we wouldn't have discovered the ideal intersection of user experience, visual, and technical.</span></p>
<p><span style="font-weight: 400;">Press Play的實際繪圖動畫是工作中設計協作的一個示例。一隊跨學科專家團隊，共同解決具有更大影響的設計和開發挑戰。沒有設計協作，我們將找不到用戶體驗，視覺和技術之間的理想交匯處。</span></p>
<p></p>
<p><span style="font-weight: 400;">When the customer saw the animation alive in his app he called it "groundbreaking."</span></p>
<p><span style="font-weight: 400;">當客戶在他的應用程序中看到動畫是生動時，他稱其為“開創性的”。</span></p>
<p></p>
<p><span style="font-weight: 400;">What’s more, the research, collaboration, and creation of this Press Play experience helped us discover a gap in the product’s user journey. Originally, the live drawing’s intent was to be a fun way to show the results to users. As we moved through the design process, we realized that if a user doesn’t watch the live drawing, and they lose, they don’t get to experience an end to their user journey for that drawing.</span></p>
<p><span style="font-weight: 400;">此外，對這種Press Play體驗的研究、協作和創造，幫助我們發現了產品用戶旅程中的空白。最初，實際繪圖的目的是將結果顯示給用戶的一種有趣的方式。在設計過程中，我們意識到，如果用戶不因為觀看實際圖形而迷失了方向，那麼他們就不會體驗到該圖形的用戶旅程。</span></p>
<p></p>
<p><span style="font-weight: 400;">From that discovery, we decided to improve the app in a couple of other places as well. We added a results/live drawing element to the Winner’s Circle and a win-lose history section to the User Details side of the app. In the end, design collaboration empowered us to realize this unfulfilled need in the user experience.</span></p>
<p><span style="font-weight: 400;">基於這一發現，我們決定在其他兩個地方也改進該應用程序。我們在“獲勝者圈子”中添加了一個結果/實際繪圖元素，並在應用程序的“用戶詳細信息”端添加了“輸贏歷史記錄”部分。最後，設計協作使我們能夠實現用戶體驗中這未滿足的需求。</span></p>
<p></p>
<p><span style="font-weight: 400;">Concluding Note</span></p>
<p><span style="font-weight: 400;">結論說明</span></p>
<p></p>
<p><span style="font-weight: 400;">It takes design collaboration to tackle the complex, crucial problems that come along with building great products and experiences. By leveraging the specialized expertise of multiple team members across disciplines, design collaboration makes sure teams meet challenges from all perspectives and come to better solutions. With the right mindset, tools, and process, design collaboration empowers teams to go deeper with creative thinking and iteration.</span></p>
<p><span style="font-weight: 400;">它需要設計協調來處理構建出色的產品和體驗所伴隨的複雜並關鍵的問題。通過利用跨學科的多個團隊成員的專業知識，設計協作可確保團隊從各個角度應對挑戰並尋求更好的解決方案。通過正確的思維方式、工具和流程，設計協調能使團隊能夠通過創造性思維和更深入迭代。</span></p>
<p></p>
<p><span style="font-weight: 400;">We hope this guide gives you a good foundation from which you can build your own effective design collaboration process. You can learn more about design and product strategy on the Savvy blog, and feel free to contact us for help on the Savvy Apps website.</span></p>
<p><span style="font-weight: 400;">我們希望本指南為您提供一個良好的基礎，您可以以此為基礎建立自己的有效設計協作流程。您可以在Savvy博客上了解有關設計和產品策略的更多信息，也可以隨時在Savvy Apps網站上與我們聯繫以獲取幫助。</span></p>
<h2>Week 10~14</h2>
<p>Week10</p>
<p>設定 API :<br/>1.登入學校的 gmail<br/>2.進入 <span lang="zh-TW"><a href="https://console.developers.google.com/">https://console.developers.google.com<br/>3</a>.接受認證並開始創建 Google API<br/>4.啟用 Google API<br/>5.在 Google Domain API 憑據下，選擇同意按鈕<br/>6.選擇內部或外部用戶類型並添加新的應用程序名稱<br/>7.在「API 和服務下」，進入<span>「</span>憑據<span>」</span>頁面<br/>8.為 Web 應用程序創建<span>「</span> OAuth 2.0 客戶端 ID<span>」</span>類型的憑據<br/>9.(設置網址)授權的 JavaScript 為：https：// localhost：8443<br/>10.定義URI為：https：// localhost：8443 / login / google /<br/>11.將 oauth_gm.txt 保存中<br/>12.開啟 leo 更改其中 config 中的 scrum 為自己命名的 txt 檔案名稱，並且修改完成之後按下 save 和 darwROC<br/>13.在黑窗輸入 pip install authomatic<br/>14.開啟 https://localhost:8443<br/>15.測試是否可以成功運作<br/></span></p>
<p><span lang="zh-TW">Week11</span></p>
<p><span lang="zh-TW">開會記錄</span></p>
<p><span lang="zh-TW"><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="//www.youtube.com/embed/jr4IxIwdHLk" width="560"></iframe></span></p>
<p><span lang="zh-TW"></span></p>
<p><span lang="zh-TW">小組分工<br/></span></p>
<p></p>
<p>topic2:</p>
<p>coppeliasim:<br/> 40723221</p>
<p>MSModelingAndTFApproaches.pdf. 207頁:7人<br/> 40723249<br/> 40623117<br/> 40723221<br/> 40723228<br/> 40723236<br/> 40723237<br/> 40723243</p>
<p><br/>MechatronicDesignCases.pdf. 46頁:2人<br/> 40723222<br/> 40723244</p>
<p>topic3:</p>
<p>MechaFutureAndChallenges.pdf. 38頁:2人<br/> 40623252<br/> 40523253</p>
<p>MechaEducFutureNeed.pdf. 20頁:1人<br/> 40723240</p>
<p>Ubuntu 設置</p>
<p><br/>1.下載 Ubuntu<br/>2.在喜好設定的網路中新增 NAT 網路<br/>3.匯入剛剛下載下來得 ubuntu<br/>4.設定中的網路中的附加到設定為僅限主機介面卡(host-only)<br/>5.啟動 ubuntu 並輸入密碼 <span>kmol2020</span><br/>6.點選右上方 activites 並點選 show application<br/>7.點選 LX terminal<br/>8.輸入 xterm&amp;<br/>9.進入資料夾中輸入 cd coppeliasim4_rev4<br/>10.輸入 cd CoppeliaSim_Edu_V4_0_0_ubuntu18_04<br/>11.再輸入 ./coppeliaSim.sh</p>
<p>Week12</p>
<p>將小組分工的翻譯完成<br/>這是我要翻譯的部分</p>
<p><span style="font-weight: 400;">After reading this chapter the reader will:</span></p>
<p></p>
<ol>
<li><span style="font-weight: 400;"> experiment his knowledge in regard to the design and real time implementation of mechatronic systems</span></li>
<li><span style="font-weight: 400;"> live the design of mechatronic systems from A to Z</span></li>
<li><span style="font-weight: 400;"> be able to perform the different phases of the design of mechatronicsystems</span></li>
<li><span style="font-weight: 400;"> be able to solve the control problem and establish the control law that we have to implement in real time</span></li>
<li><span style="font-weight: 400;"> be able to write programs in C language using the interrupt concept for real time implementation</span></li>
</ol>
<p><span style="font-weight: 400;">閱讀完本章後，讀者將：</span></p>
<p></p>
<p><span style="font-weight: 400;">1.實驗他在設計和實時方面的知識機電系統的實施</span></p>
<p><span style="font-weight: 400;">2.進行從A到Z的機電系統設計</span></p>
<p><span style="font-weight: 400;">3.能夠執行機電一體化設計的不同階段系統</span></p>
<p><span style="font-weight: 400;">4.能夠解決控制問題並建立控制律我們必須實時實施</span></p>
<p><span style="font-weight: 400;">5.能夠使用C語言的中斷概念編寫程序實時實施</span></p>
<p></p>
<p><span style="font-weight: 400;">11.1 Introduction</span></p>
<p></p>
<p><span style="font-weight: 400;">In the previous chapters we developed some concepts that we illustrated their appli-cations by academic examples to show the readers how these results apply. More specifically, we have seen how to design the mechatronic systems and we have presented the different steps that we must follow to success the design of the desired mechatronic system. We have presented the approaches that we must use in the design of:</span></p>
<p></p>
<ul>
<li><span style="font-weight: 400;"> the mechanical part</span></li>
<li><span style="font-weight: 400;"> the electronic circuit</span></li>
<li><span style="font-weight: 400;"> the program in C for the real-time implementation</span></li>
</ul>
<p><span style="font-weight: 400;">在前面的章節中，我們開發了一些概念，說明了它們的應用。通過學術實例向讀者展示這些結果如何應用。更多具體來說，我們已經了解瞭如何設計機電一體化系統，並且介紹了成功完成所需目標設計所必須遵循的不同步驟機電系統。我們已經介紹了我們必須在設計：</span></p>
<p></p>
<ul>
<li><span style="font-weight: 400;">機械部分</span></li>
<li><span style="font-weight: 400;">電子線路</span></li>
<li><span style="font-weight: 400;">C語言中用於實時執行的程序</span></li>
</ul>
<p></p>
<p><span style="font-weight: 400;">These tools were applied for some practical systems and more details were given to help the reader to execute his own design.</span></p>
<p><span style="font-weight: 400;">這些工具已用於一些實際系統，並提供了更多詳細信息幫助讀者執行自己的設計。</span></p>
<p></p>
<p><span style="font-weight: 400;">For the control algorithms most of the examples we presented were academic with perfect models. Unfortunately, for a practical system the model we will have is just a realization that may describe the system in some particular conditions, and for some reasons this model will not work perfectly as expected during the real-time implementation of the algorithms. This can be caused by different neglected dynamics that may change the behavior for some frequencies.</span></p>
<p><span style="font-weight: 400;">對於控制算法，我們提供的大多數示例都是具有理想模型的學術模型。不幸的是，對於一個實際的系統，我們將擁有的模型只是一個可以在某些特定條件下描述該系統的實現，並且由於某些原因，該模型無法在算法的實時實現過程中按預期方式完美運行。這可能是由不同的被忽略的動力學引起的，這些動力學可能會改變某些頻率的行為。</span></p>
<p></p>
<p><span style="font-weight: 400;">The aim of this chapter is to show the reader how we can implement in real-time the theoretical results we developed earlier in the previous chapters for practical systems. We will proceed gradually and show all the steps to make it easy for the readers. The case studies we consider in this chapter are those that are discussed and designed in the previous chapters.</span></p>
<p><span style="font-weight: 400;">本章的目的是向讀者展示我們如何實時實現前面幾章中針對實際系統開發的理論結果。我們將逐步進行並顯示所有步驟，以使讀者輕鬆閱讀。我們在本章中考慮的案例研究是在前幾章中討論和設計的案例研究。</span></p>
<p></p>
<p><span style="font-weight: 400;">11.2 Velocity Control of the dc Motor Kit</span></p>
<p></p>
<p><span style="font-weight: 400;">As a first example, let us consider the speed control of the dc motor driving a me-chanical part. The choice of this example is very important since most of the systems will use such dc motor. The dc motor we will consider is manufactured by Maxon company. This motor is very important since it comes with a gearbox (ratio 6:1) and an encoder that gives one hundred pulses per revolution, which gives 600 pulses per revolution that we exploit by using quadrature method to bring it to two thousand four hundred pulses per revolution. The system we are using in this example for the real-time implementation of control algorithms we presented earlier if more flexible and offer more advantages.</span></p>
<p><span style="font-weight: 400;">作為第一個示例，讓我們考慮驅動機械零件的直流電動機的速度控制。該示例的選擇非常重要，因為大多數係統將使用此類直流電動機。我們將考慮的直流電動機由Maxon公司製造。該電動機非常重要，因為它帶有齒輪箱（比率6：1）和編碼器，該編碼器每轉給出一百個脈衝，我們每轉產生600個脈衝，我們通過使用正交方法將其變為24400個脈衝。每轉。本示例中使用的系統用於實時實現控制算法，如果更靈活並且具有更多優勢，我們將在前面介紹。</span></p>
<p></p>
<p><span style="font-weight: 400;">The data sheet of this motor gives all the important parameters and therefore the transfer function of this actuator can be obtained easily. The load we are considering in this example is a small disk with graduation that we would like to control in speed and later on in position. This setup is illustrated in Figs. 11.1-(11.2). The disk we are considering has a diameter equal to 0.06 m and a mass equal to 0.050 Kg. With these data and the one of the data sheet of the dc motor, we can get the transfer function between the velocity of the disk and the input voltage.</span></p>
<p><span style="font-weight: 400;">該電動機的數據表提供了所有重要參數，因此可以輕鬆獲得該執行器的傳遞函數。在此示例中，我們正在考慮的負載是一個帶有刻度的小磁盤，我們希望在速度上控制它，然後在位置上進行控制。這種設置在圖1和2中示出。 11.1-（11.2）。我們正在考慮的圓盤的直徑等於0.06 m，質量等於0.050 Kg。利用這些數據和直流電動機的數據表之一，我們可以獲得磁盤速度和輸入電壓之間的傳遞函數。</span></p>
<p><img alt="" height="316" src="/images/MechatronicsicDesignCases-1.jpg" width="572"/></p>
<p><span style="font-weight: 400;">                                  Fig. 11.1 Electronic circuit of dc motor kit</span></p>
<p></p>
<p><span style="font-weight: 400;">or proceed with an identification. Using the first approach the results of Chapter 2 in [1], we get:</span></p>
<p><span style="font-weight: 400;">或繼續進行識別。使用第一種方法，[1]中第2章的結果是：</span></p>
<p><span style="font-weight: 400;"><img alt="" height="127" src="/images/MechatronicsicDesignCases-2.jpg" width="452"/></span></p>
<p><span style="font-weight: 400;">For the identification of our system, we can do it in real-time using the real- time implementation setup and appropriate C program. Since the microcontroller owns limited memory, the identification can be done into two steps. Firstly, in a first experiment the gain, K, is determined, then using this gain we compute the steady state value that can be used to compute the constant time τ.</span></p>
<p><span style="font-weight: 400;">為了識別我們的系統，我們可以使用實時實施設置和適當的C程序實時進行識別。由於微控制器擁有有限的存儲器，因此識別可以分為兩個步驟。首先，在第一個實驗中，確定增益K，然後使用該增益來計算可用於計算恆定時間τ的穩態值。</span></p>
<p></p>
<p><span style="font-weight: 400;">To design the controller we should first of all specify the performances we would like that our system has. As a first performance, we require that our system is stable. It is also needed that the system speed will have a good behavior at the transient regime with a zero error at the steady state regime for a step reference. For the transient we would like that our load has a settling time with 5% less or equal to 3τ/5 and an overshoot less or equal to 5%.</span></p>
<p><span style="font-weight: 400;">為了設計控制器，我們首先應該指定我們希望系統具有的性能。作為首要性能，我們要求系統穩定。還需要係統速度在瞬態狀態下具有良好的性能，並且在穩態狀態下的零誤差作為階躍參考。對於瞬態，我們希望負載的穩定時間小於或等於3τ/ 5 5％，而過衝則小於或等於5％。</span></p>
<p></p>
<p><span style="font-weight: 400;">To accomplish the design of the appropriate controller we can either make the design in continuous-time and then obtain the algorithm we should program in the software part, or proceed with all the design in the discrete-time directly. In the rest of this example, we will opt for the second approach.</span></p>
<p><span style="font-weight: 400;">為了完成適當控制器的設計，我們既可以連續進行設計，然後獲得應在軟件部分進行編程的算法，也可以直接在離散時間內進行所有設計。在本示例的其餘部分中，我們將選擇第二種方法。</span></p>
<p><img alt="" height="366" src="/images/MechatronicsicDesignCases-3.jpg" width="327"/></p>
<p><span style="font-weight: 400;">                                          Fig. 11.2 Real-time implementation setup</span></p>
<p></p>
<p><span style="font-weight: 400;">From the expression of the system transfer function, and the desired perfor-mances it results that we need at least a proportional and integrator (PI) controller.</span></p>
<p><span style="font-weight: 400;">從系統傳遞函數的表達式以及所需的性能來看，我們至少需要一個比例積分器（PI）控制器。</span></p>
<p></p>
<p><span style="font-weight: 400;">The transfer function of this controller is given by:</span></p>
<p><span style="font-weight: 400;">該控制器的傳遞函數由下式給出：</span></p>
<p><img alt="" height="83" src="/images/MechatronicsicDesignCases-4.jpg" width="339"/></p>
<p><span style="font-weight: 400;">where KP and KI are gains to be determined to force the load to have the performances we imposed.</span></p>
<p><span style="font-weight: 400;">其中KP和KI是要確定的結果，以迫使負載具有我們施加的性能。</span></p>
<p></p>
<p><span style="font-weight: 400;">Using a zero-order-holder and the Z -transform table we get:</span></p>
<p><span style="font-weight: 400;">使用零序持有者和Z -transform表，我們得到：</span></p>
<p><span style="font-weight: 400;"><img alt="" height="109" src="/images/MechatronicsicDesignCases-5.jpg" width="479"/></span></p>
<p><span style="font-weight: 400;">For the controller, using the trapezoidal discretisation we get:</span></p>
<p><span style="font-weight: 400;">對於控制器，使用梯形離散化，我們得到：</span></p>
<p><span style="font-weight: 400;"><img alt="" height="112" src="/images/MechatronicsicDesignCases-6.jpg" width="525"/></span></p>
<p><span style="font-weight: 400;">Dividing the numerator and the denominator by z and going back to time, we get:</span></p>
<p><span style="font-weight: 400;">將分子和分母除以z並回到時間，我們得到：</span></p>
<p><span style="font-weight: 400;"><img alt="" height="54" src="/images/MechatronicsicDesignCases-7.jpg" width="544"/></span></p>
<p><span style="font-weight: 400;">Combining the transfer function of the actuator and its load and the one of the controller we get the following closed-loop transfer function:</span></p>
<p><span style="font-weight: 400;">結合執行器及其負載和控制器之一的傳遞函數，我們得到以下閉環傳遞函數：</span></p>
<p><span style="font-weight: 400;"><img alt="" height="64" src="/images/MechatronicsicDesignCases-8.jpg" width="478"/></span></p>
<p><span style="font-weight: 400;">Using now the desired performances, it is easy to conclude that the dominant poles are</span></p>
<p><span style="font-weight: 400;">現在使用期望的性能，很容易得出結論，主導極點是</span></p>
<p></p>
<p><span style="font-weight: 400;">where ζ and ωn represent respectively the damping ratio and the natural frequency of the closed-loop of our system control.</span></p>
<p><span style="font-weight: 400;">其中ζ和ωn分別代表我們系統控制閉環的阻尼比和固有頻率。</span></p>
<p></p>
<p><span style="font-weight: 400;">From control theory (see Boukas [1]) it is well known that the overshoot d% and the settling time ts at 5% are given by:</span></p>
<p><span style="font-weight: 400;">根據控制理論（請參見Boukas [1]），眾所周知，過衝d％和5％的建立時間ts由下式給出：</span></p>
<p><span style="font-weight: 400;"><img alt="" height="78" src="/images/MechatronicsicDesignCases-9.jpg" width="461"/></span></p>
<p><span style="font-weight: 400;">Using our performances and these expressions we conclude that:</span></p>
<p><span style="font-weight: 400;">使用我們的表演和這些表達，我們得出以下結論：</span></p>
<p><span style="font-weight: 400;"><img alt="" height="84" src="/images/MechatronicsicDesignCases-10.jpg" width="505"/></span></p>
<p><span style="font-weight: 400;">which give the following dominant poles:</span></p>
<p><span style="font-weight: 400;">它具有以下主要優勢：</span></p>
<p><span style="font-weight: 400;"><img alt="" height="31" src="/images/MechatronicsicDesignCases-11.jpg" width="485"/></span></p>
<p><span style="font-weight: 400;">Using the transformation z = eT s with T = τ/10 = 0.0064, we obtain the following dominant poles in the Z -domain:</span></p>
<p><span style="font-weight: 400;">使用Z = eT s且T =τ/ 10 = 0.0064的變換，我們在Z域中獲得以下主導極點：</span></p>
<p><span style="font-weight: 400;"><img alt="" height="29" src="/images/MechatronicsicDesignCases-12.jpg" width="495"/></span></p>
<p><span style="font-weight: 400;">Using now the poles placement technique we get:</span></p>
<p><span style="font-weight: 400;">現在使用極點放置技術，我們得到：</span></p>
<p><span style="font-weight: 400;"></span></p>
<p><span style="font-weight: 400;">which implies:</span></p>
<p><span style="font-weight: 400;">這意味著：</span></p>
<p><span style="font-weight: 400;">Using the values of K, T and τ, we get the following expression for the gains KP and KI:</span></p>
<p><span style="font-weight: 400;">使用K，T和τ的值，我們得到增益KP和KI的以下表達式：</span></p>
<p><b>Remark 11.2.1</b><span style="font-weight: 400;"> Cautions have to be made in this case since we don’t care about the positions of the zero of the transfer function and therefore we may have some surprises when implementing this controller. It is clear that the performances we will get (settling time and the overshoot) will depend on the positions of the zero. For more details on this matter we refer the reader to Boukas [1].</span></p>
<p><span style="font-weight: 400;">備註11.2.1在這種情況下，必須謹慎，因為我們不在乎傳遞函數零的位置，因此在實現此控制器時可能會有些意外。顯然，我們將獲得的性能（穩定時間和過衝）將取決於零的位置。有關此問題的更多詳細信息，請向讀者介紹Boukas [1]。</span></p>
<p></p>
<p><span style="font-weight: 400;">To implement now this PI control algorithm and assure the desired performances we will use a microcontroller from Microship1. This choice is due to our experience with this type of microcontroller. The reader can keep in mind that any other micro-controller from other manufacturer with some small changes will do the job. In this example we will use the microcontroller dsPIC30F4011 from Microhip.</span></p>
<p><span style="font-weight: 400;">為了實現此PI控制算法並確保所需的性能，我們將使用Microship1的微控制器。這種選擇是由於我們在此類微控制器方面的經驗所致。讀者可以記住，其他製造商的任何其他微控制器只要稍作改動，就可以完成工作。在本示例中，我們將使用Microhip的單片機dsPIC30F4011。</span></p>
<p></p>
<p><span style="font-weight: 400;">The code for our implementation is made in C-language. This language is adopted for its simplicity. The implementation has the following structure:</span></p>
<p><span style="font-weight: 400;">我們實現的代碼使用C語言編寫。採用這種語言是因為其簡單性。該實現具有以下結構：</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// Put here the include</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">#include "p30F4011.h" // proc specific header</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// Define a struct</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">typedef struct {</span></p>
<p><span style="font-weight: 400;">// PI Gains</span></p>
<p><span style="font-weight: 400;">float K_P; // Propotional gain</span></p>
<p><span style="font-weight: 400;">float K_I; // Integral gain</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// PI Constants</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">float Const1_pid; // KP + T KI/2</span></p>
<p><span style="font-weight: 400;">float Const2_pid; // -KP + T KI/2</span></p>
<p><span style="font-weight: 400;">float Reference; // speed reference</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// System variables</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">float y_k; // y_m[k] -&gt; measured output at time k</span></p>
<p><span style="font-weight: 400;">float u_k; // u[k] -&gt; output at time k</span></p>
<p><span style="font-weight: 400;">float e_k; // e[k] -&gt; error at time k</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// System past variables</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">float u_prec; // u[k-1] -&gt; output at time k-1</span></p>
<p><span style="font-weight: 400;">float e_prec; // e[k-1] -&gt; error at time k-1</span></p>
<p><span style="font-weight: 400;">}PIStruct;</span></p>
<p><span style="font-weight: 400;">PIStruct thePI;</span></p>
<p><span style="font-weight: 400;">thePI.Const1= thePI.K_P+T*thePI.K_I/2;</span></p>
<p><span style="font-weight: 400;">thePI.Const2=-thePI.K_P+T*thePI.K_I/2;</span></p>
<p><span style="font-weight: 400;">thePI.Reference=600;</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// Functions</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">float ReadSpeed(void);</span></p>
<p><span style="font-weight: 400;">float ComputeControl(void);</span></p>
<p><span style="font-weight: 400;">float SendControl(void);</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// Interrupt program here using Timer 1 (overflow of counter Timer 1)</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">void __ISR _T1Interrupt(void) // interrupt routine code</span></p>
<p><span style="font-weight: 400;">{</span></p>
<p><span style="font-weight: 400;">// Interrupt Service Routine code goes here</span></p>
<p><span style="font-weight: 400;">float Position_error;</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// Read speed</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">thePI.y_m=ReadSpeed();</span></p>
<p><span style="font-weight: 400;">thePI.e_k= thePI.Reference-thePI.y_m;</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// Compute the control</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">ComputeContrl();</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// Send control</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">SendControl();</span></p>
<p><span style="font-weight: 400;">IFS0bits.T1IF=0; // Disable the interrupt</span></p>
<p><span style="font-weight: 400;">}</span></p>
<p><span style="font-weight: 400;">int main ( void ) // start of main application code</span></p>
<p><span style="font-weight: 400;">{</span></p>
<p><span style="font-weight: 400;">// Application code goes here</span></p>
<p><span style="font-weight: 400;">int i;</span></p>
<p><span style="font-weight: 400;">// Initialize the variables Reference and ThePID.y_m (it can be read</span></p>
<p><span style="font-weight: 400;">from inputs) Reference = 0x8000; // Hexadecimal number</span></p>
<p><span style="font-weight: 400;">(0b... Binary number) ThePID = 0x8000;</span></p>
<p><span style="font-weight: 400;">// Initialize the registers</span></p>
<p><span style="font-weight: 400;">TRISC=0x9fff; // RC13 and RC14 (pins 15 and 16) are configured as outputs</span></p>
<p><span style="font-weight: 400;">IEC0bits.T1IE=1; // Enable the interrupt on Timer 1</span></p>
<p><span style="font-weight: 400;">// Indefinite loop</span></p>
<p><span style="font-weight: 400;">while (1)</span></p>
<p><span style="font-weight: 400;">{</span></p>
<p><span style="font-weight: 400;">}</span></p>
<p><span style="font-weight: 400;">return 0</span></p>
<p><span style="font-weight: 400;">}</span></p>
<p><span style="font-weight: 400;">% ReadSpeed function</span></p>
<p><span style="font-weight: 400;">int ReadSpeed (void)</span></p>
<p><span style="font-weight: 400;">{</span></p>
<p><span style="font-weight: 400;">}</span></p>
<p><span style="font-weight: 400;">% ComputeControl function</span></p>
<p><span style="font-weight: 400;">int ComputeControl (void)</span></p>
<p><span style="font-weight: 400;">{</span></p>
<p><span style="font-weight: 400;">thePI.u_k=thePI.u_prec+thePI.Const1*thePI.e_k+thePI.Const2*thePI.e_prec;</span></p>
<p><span style="font-weight: 400;">}</span></p>
<p><span style="font-weight: 400;">% SendControl function</span></p>
<p><span style="font-weight: 400;">int Send Control (void)</span></p>
<p><span style="font-weight: 400;">{</span></p>
<p><span style="font-weight: 400;">sendControl()</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">// Update past data</span></p>
<p><span style="font-weight: 400;">//</span></p>
<p><span style="font-weight: 400;">thePI.u_prec=thePI.u_k;</span></p>
<p><span style="font-weight: 400;">ThePI.e_prec=thePI.e_k;</span></p>
<p><span style="font-weight: 400;">}</span></p>
<p></p>
<p><span style="font-weight: 400;">As it can be seen from this structure, first of all we notice that the system will enter the loop and at each interrupt the call for the functions:</span></p>
<ul>
<li><span style="font-weight: 400;"> ReadSpeed;</span></li>
<li><span style="font-weight: 400;"> ComputeControl;</span></li>
<li><span style="font-weight: 400;"> SendControl;</span></li>
</ul>
<p><span style="font-weight: 400;">is made and the appropriate action is taken.</span></p>
<p><span style="font-weight: 400;">從該結構可以看出，首先我們注意到系統將進入循環，並在每次中斷時調用函數：</span></p>
<ul>
<li><span style="font-weight: 400;">ReadSpeed；</span></li>
<li><span style="font-weight: 400;">ComputeControl；</span></li>
<li><span style="font-weight: 400;">SendControl；</span></li>
</ul>
<p><span style="font-weight: 400;">並採取適當的措施。</span></p>
<p></p>
<p><span style="font-weight: 400;">The ReadSpeed function returns the load speed at each sampling time that will be used by the ComputeControl function. The SendControl function sends the appropriate voltage to the actuator via the L293D chip.</span></p>
<p><span style="font-weight: 400;">ReadSpeed函數在每個採樣時間返回加載速度，該速度將由ComputeControl函數使用。 SendControl功能通過L293D芯片將適當的電壓發送到執行器。</span></p>
<p></p>
<p><span style="font-weight: 400;">Using the compiler HighTec C to get the hex code and the PicKit-2 to upload the file in the memory of the microcontroller. For more detail on how to get the hex code we invite the reader to the manual of the compiler HighTec C or the compiler C30 of Microchip.</span></p>
<p><span style="font-weight: 400;">使用編譯器HighTec C獲取十六進制代碼，並使用PicKit-2將文件上傳到微控制器的內存中。有關如何獲取十六進制代碼的更多詳細信息，我們邀請讀者閱讀編譯器HighTec C或Microchip的編譯器C30的手冊。</span></p>
<p></p>
<p><span style="font-weight: 400;">The state approach in this case is trivial and we will not develop it.</span></p>
<p><span style="font-weight: 400;">在這種情況下，國家方法是微不足道的，我們將不發展它。</span></p>
<p></p>
<p><span style="font-weight: 400;">11.3 Position Control of the dc Motor Kit</span></p>
<p></p>
<p><span style="font-weight: 400;">Let us focus on the load position control. Following similar steps as for the load ve-locity control developed in the previous section, we need firstly to choose the desired performances we would like our system will have. The following performances are imposed:</span></p>
<ul>
<li><span style="font-weight: 400;"> system stable in the closed-loop;</span></li>
<li><span style="font-weight: 400;"> settling time ts at 2% equal to the best one we can have</span></li>
<li><span style="font-weight: 400;"> overshoot equal to 5%</span></li>
<li><span style="font-weight: 400;"> steady-state equal to zero for a step function as input</span></li>
</ul>
<p><span style="font-weight: 400;">讓我們專注於負載位置控制。遵循與上一節中開發的負載速度控制類似的步驟，我們首先需要選擇我們希望系統具有的理想性能。進行以下表演：</span></p>
<ul>
<li><span style="font-weight: 400;">系統穩定在閉環狀態；</span></li>
<li><span style="font-weight: 400;">穩定時間ts為2％，等於我們可以擁有的最佳時間</span></li>
<li><span style="font-weight: 400;">超調等於5％</span></li>
<li><span style="font-weight: 400;">步進功能作為輸入的穩態等於零</span></li>
</ul>
<p></p>
<p><span style="font-weight: 400;">Using the performances and the transfer function, it is easy to conclude that a proportional controller KP is enough to satisfy these performances.</span></p>
<p><span style="font-weight: 400;">使用性能和傳遞函數，很容易得出結論，比例控制器KP足以滿足這些性能。</span></p>
<p></p>
<p><span style="font-weight: 400;">In this example, we will use the continuous-time approach for the design of the controller. Based on the past chapter, the model of our system is given by:</span></p>
<p><span style="font-weight: 400;">在此示例中，我們將使用連續時間方法進行控制器的設計。在上一章的基礎上，我們的系統模型如下：</span></p>
<p><span style="font-weight: 400;">where K and τ take the same values as for the speed control.Let the transfer controller be give by:</span></p>
<p><span style="font-weight: 400;">其中K和τ的取值與速度控制的取值相同。</span></p>
<p><span style="font-weight: 400;">Using these expression, the closed-loop transfer function is given by:</span></p>
<p><span style="font-weight: 400;">使用這些表達式，閉環傳遞函數由下式給出：</span></p>
<p><span style="font-weight: 400;">Since the system is of type 1, it results that the error to a step function as input is equal to zero with a proportional controller.Based on the specifications, the following complex poles:</span></p>
<p><span style="font-weight: 400;">由於系統類型為1，因此使用比例控制器時，輸入階躍函數的誤差等於零。根據規格，以下複雜極點：</span></p>
<p><span style="font-weight: 400;">will do the job and the corresponding characteristic equation is given by:</span></p>
<p><span style="font-weight: 400;">將完成這項工作，相應的特徵方程式如下：</span></p>
<p><span style="font-weight: 400;">Equating this with the one of the closed-loop system we get:</span></p>
<p><span style="font-weight: 400;">與閉環系統之一等效，我們得到：</span></p>
<p><span style="font-weight: 400;">To determine the best settling time ts at 2 %, notice that we have:</span></p>
<p><span style="font-weight: 400;">為了確定最佳穩定時間ts為2％，請注意，我們有：</span></p>
<p><span style="font-weight: 400;">Using now the fact:</span></p>
<p><span style="font-weight: 400;">現在使用事實：</span></p>
<p><span style="font-weight: 400;">we obtain:</span></p>
<p><span style="font-weight: 400;">我們獲得：</span></p>
<p><span style="font-weight: 400;">Therefore the best settling time at %2 we can have with this controller is 8 times the constant time of the system. Any value less than will be attainable. In fact, this is trivial if we look to the root locus of the closed-loop system when varying KP. This is given by Fig. 11.3. To fix the gain of the controller the desired poles s1,2 = −7.5±j, we use the figure and choosing a ζ = 0.707. This gives KP = 0.1471.</span></p>
<p><span style="font-weight: 400;">因此，使用此控制器可以在％2處獲得的最佳建立時間是系統恆定時間的8倍。小於可獲得的任何值。實際上，如果我們在改變KP時關注閉環系統的根源，這是微不足道的。這由圖11.3給出。為了將控制器的增益固定為所需的極點s1,2 = -7.5±j，我們使用該圖並選擇ζ= 0.707。得出KP = 0.1471。</span></p>
<p><span style="font-weight: 400;">                     Fig. 11.3 Root locus of the dc motor with a proportional controller</span></p>
<p></p>
<p><span style="font-weight: 400;">Using this controller, the time response for a step function of amplitude equal to 30 degrees is represented by the Fig. 11.4 from which we conclude that the designed controller satisfies all the desired performances with a settling time at %2 equal to 0.5115 s. But if we implement this controller, the reality will be different from simulation since the backlash of the gearbox is not included in the used model and therefore in real-time the result will be different and the error will never be zero. To overcome this problem we can use a proportional and derivative controller that may give better settling time at %2. Let the transfer function of this controller be given by:</span></p>
<p><span style="font-weight: 400;">使用該控制器，幅度等於30度的階躍函數的時間響應由圖11.4表示，從中我們可以得出結論，所設計的控制器以％2的穩定時間等於0.5115 s滿足了所有期望的性能。但是，如果我們實現此控制器，則實際情況將與仿真有所不同，因為變速箱的齒隙並未包含在所使用的模型中，因此實時結果將有所不同，誤差永遠不會為零。為了克服這個問題，我們可以使用比例和微分控制器，它可以在％2處提供更好的建立時間。讓該控制器的傳遞函數由下式給出：</span></p>
<p><span style="font-weight: 400;">where KP and KD are the gain to be determined.</span></p>
<p><span style="font-weight: 400;">其中KP和KD是要確定的增益。</span></p>
<p></p>
<p><b>Remark 11.3.1</b><span style="font-weight: 400;"> It is important to notice that the use of a proportional and deriva-tive controller will introduce a zero in the closed-loop transfer that may improve the settling time if it is well placed. Depending on its position, the overshoot and the settling time will be affected. For more details on this matter we refer the reader to [1].</span></p>
<p><span style="font-weight: 400;">備註11.3.1必須注意，使用比例和微分控制器會在閉環傳遞中引入零，這可能會改善放置時間是否合適。根據其位置，過沖和建立時間將受到影響。有關此問題的更多詳細信息，請參考[1]</span></p>
<p><span style="font-weight: 400;">                 Fig. 11.4 Time response for a step function with 30 degrees as amplitude</span></p>
<p></p>
<p><span style="font-weight: 400;">With this controller the closed-loop transfer function is given by:</span></p>
<p><span style="font-weight: 400;">使用該控制器，閉環傳遞函數由下式給出：</span></p>
<p><span style="font-weight: 400;">As before two complex poles are used for the design of the controller. If we equate the two characteristic equations we get:</span></p>
<p><span style="font-weight: 400;">和以前一樣，控制器的設計使用了兩個複雜的極點。如果將兩個特徵方程式相等，則得到：</span></p>
<p><span style="font-weight: 400;">In this case we have two unknown variables KP and KD and two algebraic equations which determines uniquely the gains. Their expressions are given by:</span></p>
<p><span style="font-weight: 400;">在這種情況下，我們有兩個未知變量KP和KD以及兩個唯一確定增益的代數方程。它們的表達式如下：</span></p>
<p><span style="font-weight: 400;">Using now the desired performances, we conclude similarly as before that the steady error to an input equal to step function of amplitude equal to 30 degrees for instance is equal to zero and the damping ratio ζ corresponding to an overshoot equal to %5 is equal to 0.707. The settling time, ts at % 2, that we may fix as a proportion of the time constant of the system, gives:</span></p>
<p><span style="font-weight: 400;">現在，使用期望的性能，我們得出與之前類似的結論，即等於等於30度的幅度階躍函數的輸入的穩態誤差等於零，並且與過衝等於％5的阻尼比ζ等於0.707。我們可以將其固定為系統時間常數的一部分的穩定時間ts在％2處給出：</span></p>
<p><span style="font-weight: 400;">Now if we fix the settling time at 3τ, we get:</span></p>
<p><span style="font-weight: 400;">現在，如果將穩定時間固定為3τ，我們將得到：</span></p>
<p><span style="font-weight: 400;">Using these values we get the following ones for the controller gains:</span></p>
<p><span style="font-weight: 400;">使用這些值，我們可以得到以下控制器增益值：</span></p>
<p><span style="font-weight: 400;">which gives the following complex poles:</span></p>
<p><span style="font-weight: 400;">它給出了以下複雜的兩極：</span></p>
<p><span style="font-weight: 400;">and the zero at:</span></p>
<p><span style="font-weight: 400;">零為：</span></p>
<p><span style="font-weight: 400;">Using this controller the time response for an input with an amplitude equal to 30 degrees is represented in Fig. 11.5. As it can be seen from this figure that the overshoot and the settling time are less those obtained using the proportional controller.</span></p>
<p><span style="font-weight: 400;">使用該控制器，幅度等於30度的輸入的時間響應如圖11.5所示。從該圖可以看出，過沖和建立時間少於使用比例控制器獲得的過沖和建立時間。</span></p>
<p></p>
<p><span style="font-weight: 400;">To implement either the proportional or the proportional and derivative con-trollers we need to get the recurrent equation for the control law. For this purpose, we need to discretize the transfer function of the controller using the different meth-ods presented earlier. Let us use the trapezoidal method which consists to replace s by 2(z−1)/T(z+1) . This gives:</span></p>
<p><span style="font-weight: 400;">為了實現比例控制器或比例控制器和微分控制器，我們需要獲得控制律的遞推方程。為此，我們需要使用前面介紹的不同方法來離散化控制器的傳遞函數。讓我們使用梯形方法，該方法包括將s替換為2（z-1）/ T（z + 1）。這給出：</span></p>
<p><span style="font-weight: 400;">If we denote by u(k) and e(k) by the control and the error between the reference and the output at instant kT, we get the following expressions:</span></p>
<ol>
<li><span style="font-weight: 400;"> for the proportional</span></li>
</ol>
<p><span style="font-weight: 400;">如果我們通過控制分別表示u（k）和e（k）以及在瞬時kT處參考和輸出之間的誤差，我們將得到以下表達式：</span></p>
<p><span style="font-weight: 400;">1.比例</span></p>
<p><span style="font-weight: 400;">u(k) = KPe(k)</span></p>
<p></p>
<ol start="2">
<li><span style="font-weight: 400;"> for the proportional and derivative controller</span></li>
</ol>
<p><span style="font-weight: 400;">2.用於比例和微分控制器</span></p>
<p><span style="font-weight: 400;">u(k) = −u(k − 1) + (KP + 2KD/T) e(k) + (KP − 2KD/T) e(k − 1)</span></p>
<p><span style="font-weight: 400;">The implementation is this controller uses the same function with some minors changes. The listing the corresponding functions is:</span></p>
<p><span style="font-weight: 400;">實現是該控制器使用相同的功能，但有一些小的更改。列出相應的功能是：</span></p>
<p></p>
<p><span style="font-weight: 400;">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></p>
<p><span style="font-weight: 400;">% Main program                                                                                  %</span></p>
<p><span style="font-weight: 400;">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></p>
<p></p>
<p><span style="font-weight: 400;">main</span></p>
<p><span style="font-weight: 400;">% Data</span></p>
<p><span style="font-weight: 400;">% Variables</span></p>
<p><span style="font-weight: 400;">% While loop</span></p>
<p><span style="font-weight: 400;">while (1)</span></p>
<p><span style="font-weight: 400;">do</span></p>
<p><span style="font-weight: 400;">ReadSpeed;</span></p>
<p><span style="font-weight: 400;">ComputeControl;</span></p>
<p><span style="font-weight: 400;">SendControl;</span></p>
<p><span style="font-weight: 400;">end;</span></p>
<p></p>
<p><span style="font-weight: 400;">% ReadSpeed function</span></p>
<p><span style="font-weight: 400;">% ComputeControl function</span></p>
<p><span style="font-weight: 400;">% SendControl function</span></p>
<p></p>
<p><span style="font-weight: 400;">Let us now use the state space representation of this example and design a state feedback controller that will guarantee the desired performances. For this case we will firstly assume the complete access to the states and secondly we relax this as-sumption by assuming that we have access only to the position. As we did previously we can proceed either in the continuous-time or in discrete-time. Previously we establish the state space description of this system and it is given by:</span></p>
<p><span style="font-weight: 400;">現在讓我們使用此示例的狀態空間表示，並設計一個狀態反饋控制器，以保證所需的性能。對於這種情況，我們將首先假定完全訪問狀態，其次通過假定我們只能訪問該職位來放寬此假設。像我們之前所做的那樣，我們可以連續進行，也可以不連續進行。先前我們建立了該系統的狀態空間描述，其描述為：</span></p>
<p></p>
<p><span style="font-weight: 400;">where x(t) ∈ R2 (x1(t) = θ(t) and x2(t) = θ ̇(t)), and u(t) ∈ R (the applied voltage). From the desired performances with a settling time at %2 equal to 3τ, we get the same dominant poles as before, and therefore the same characteristic equation, Δd(s) = s*s + 2ζwn s + w2/n = 0 (with ζ = 0.707 and wn = 4/3ζτ ). Using the controller expression the closed-loop characteristic equations given by:</span></p>
<p><span style="font-weight: 400;">其中x（t）∈R2（x1（t）=θ（t）和x2（t）=θ̇（t）），u（t）∈R（施加電壓）。從穩定時間為％2等於3τ的期望性能中，我們得到與以前相同的主導極點，因此具有相同的特性方程Δd（s）= s * s +2ζwns + w2 / n = 0（ ζ= 0.707，wn = 4 /3ζτ）。使用控制器表達式，閉環特性方程由下式給出：</span></p>
<p></p>
<p><span style="font-weight: 400;">det (sI − A + BK) = 0</span></p>
<p></p>
<p><span style="font-weight: 400;">By equalizing these two equations we get the following gains:</span></p>
<p><span style="font-weight: 400;">通過均衡這兩個方程式，我們可以得到以下收益：</span></p>
<p></p>
<p><span style="font-weight: 400;">K1 = 1.1146</span></p>
<p><span style="font-weight: 400;">K2 = 0.0326</span></p>
<p></p>
<p><span style="font-weight: 400;">Using this controller the time response for an input with an amplitude equal to 30 degrees is represented in Fig. 11.6. As it can be seen from this figure that the overshoot and the settling time are those we would like to have. It is important to notice the existence of the error at the steady state regime. This error can be eliminated if we add an integral action in the loop. For more detail on this we refer the reader to [1].</span></p>
<p><span style="font-weight: 400;">使用該控制器，幅度等於30度的輸入的時間響應如圖11.6所示。從該圖可以看出，超調和建立時間就是我們想要的。重要的是要注意穩態狀態下錯誤的存在。如果在循環中添加一個積分動作，則可以消除此錯誤。有關此的更多詳細信息，請向讀者介紹[1]。</span></p>
<p></p>
<p><span style="font-weight: 400;">For the second case since we don’t have access to the load speed we can either compute it from the position or use an observer to estimate the system state. As it was said earlier, the poles that we use for the design of the observer should be faster than those used in the controller design.</span></p>
<p><span style="font-weight: 400;">對於第二種情況，由於我們無法獲得負載速度，因此我們可以從位置計算負載速度，也可以使用觀察者來估算系統狀態。如前所述，我們用於觀察者設計的極點應該比控制器設計中使用的極點更快。</span></p>
<p></p>
<p><span style="font-weight: 400;">we get the following gains for the observer:</span></p>
<p><span style="font-weight: 400;">我們為觀察者帶來以下收益：</span></p>
<p></p>
<p><span style="font-weight: 400;">L1 = 151.2</span></p>
<p><span style="font-weight: 400;">L2 = 5029.4</span></p>
<p></p>
<p><span style="font-weight: 400;">The gains of the controller remain the same as for the complete access case to the state vector.</span></p>
<p><span style="font-weight: 400;">控制器的增益與對狀態向量的完全訪問情況相同。</span></p>
<p></p>
<p><span style="font-weight: 400;">In the following Matlab we provide the design of the controller and the observer at the same time and give simulation that shows the behavior of the states of the system and observer with respect to time.</span></p>
<p><span style="font-weight: 400;">在下面的Matlab中，我們同時提供控制器和觀察者的設計，並進行仿真，以顯示系統和觀察者的狀態相對於時間的行為。</span></p>
<p></p>
<p><span style="font-weight: 400;">clear all</span></p>
<p></p>
<p><span style="font-weight: 400;">%data</span></p>
<p><span style="font-weight: 400;">tau=0.064</span></p>
<p><span style="font-weight: 400;">k=48.9</span></p>
<p><span style="font-weight: 400;">A = [0 1;0 -1/tau];</span></p>
<p><span style="font-weight: 400;">B = [0 ; k/tau];</span></p>
<p><span style="font-weight: 400;">C = [1 0];</span></p>
<p><span style="font-weight: 400;">D = 0;</span></p>
<p></p>
<p><span style="font-weight: 400;">% controller design</span></p>
<p><span style="font-weight: 400;">K = acker(A,B,[-3+3*j -3-3*j]);</span></p>
<p><span style="font-weight: 400;">L = acker(A’,C’,[-12+3*j -12-3*j])’;</span></p>
<p></p>
<p><span style="font-weight: 400;">% Simualation data</span></p>
<p><span style="font-weight: 400;">Ts = 0.01;</span></p>
<p><span style="font-weight: 400;">x0 = [1 ; 1];</span></p>
<p><span style="font-weight: 400;">z0 = [1.1 ; 0.9];</span></p>
<p><span style="font-weight: 400;">Tf = 2; %final time</span></p>
<p></p>
<p><span style="font-weight: 400;">%augmented system</span></p>
<p><span style="font-weight: 400;">Ah = [A -B*K;</span></p>
<p><span style="font-weight: 400;">L*C A-B*K-L*C];</span></p>
<p><span style="font-weight: 400;">Bh = zeros(size(Ah,1),1);</span></p>
<p><span style="font-weight: 400;">Ch = [C D*K];</span></p>
<p><span style="font-weight: 400;">Dh = zeros(size(Ch,1),1);</span></p>
<p><span style="font-weight: 400;">xh0 = [x0 ; z0];</span></p>
<p><span style="font-weight: 400;">t=0:Ts:Tf;</span></p>
<p><span style="font-weight: 400;">u = zeros(size(t));</span></p>
<p><span style="font-weight: 400;">m = ss(Ah,Bh,Ch,Dh);</span></p>
<p></p>
<p><span style="font-weight: 400;">%simulation</span></p>
<p><span style="font-weight: 400;">[y,t,x] = lsim(m,u,t,xh0);</span></p>
<p></p>
<p><span style="font-weight: 400;">%plotting</span></p>
<p><span style="font-weight: 400;">figure;</span></p>
<p><span style="font-weight: 400;">plot(t,y);</span></p>
<p><span style="font-weight: 400;">title(’Output’);</span></p>
<p><span style="font-weight: 400;">xlabel(’Time in sec’)</span></p>
<p><span style="font-weight: 400;">ylabel(’Output’)</span></p>
<p><span style="font-weight: 400;">grid</span></p>
<p></p>
<p><span style="font-weight: 400;">figure;</span></p>
<p><span style="font-weight: 400;">plot(t,x(:,1:size(A,1)));</span></p>
<p><span style="font-weight: 400;">title(’States of the system’);</span></p>
<p><span style="font-weight: 400;">xlabel(’Time in sec’)</span></p>
<p><span style="font-weight: 400;">ylabel(’System states’)</span></p>
<p><span style="font-weight: 400;">grid</span></p>
<p></p>
<p><span style="font-weight: 400;">figure;</span></p>
<p><span style="font-weight: 400;">plot(t,x(:,size(A,1)+1:end));</span></p>
<p><span style="font-weight: 400;">title(’states of the observer’);</span></p>
<p><span style="font-weight: 400;">xlabel(’Time in sec’)</span></p>
<p><span style="font-weight: 400;">ylabel(’Observer states’)</span></p>
<p><span style="font-weight: 400;">grid</span></p>
<p></p>
<p><span style="font-weight: 400;">Figs. (11.7)-(11.9) gives an illustration of the output, the system’s states and the observer’s states.</span></p>
<p><span style="font-weight: 400;">無花果（11.7）-（11.9）給出了輸出，系統狀態和觀察者狀態的說明。</span></p>
<p></p>
<p><span style="font-weight: 400;">Remark 11.3.2 In general, there is no magic rule for the choice the matrices for the cost function. But in general the fact that we use a high value for the control for instance will force the control to take small values and may prevent saturation. Using these matrices and the Matlab function, lqr, we get:</span></p>
<p><span style="font-weight: 400;">備註11.3.2通常，對於成本函數的矩陣選擇沒有魔術規則。但是通常，例如，我們對控件使用較高的值將迫使控件採用較小的值，並可能防止飽和。使用這些矩陣和Matlab函數lqr，我們得到：</span></p>
<p></p>
<p><span style="font-weight: 400;">K =0.3162 0.6875 </span></p>
<p></p>
<p><span style="font-weight: 400;">We can also design a state feedback controller using the results on robust control part. Since the system has no uncertainties and there is no external disturbance, we can design a state feedback controller for the nominal dynamics. Using the system data and Maltlab, we get:</span></p>
<p><span style="font-weight: 400;">我們還可以使用魯棒控制部分的結果設計狀態反饋控制器。由於系統沒有不確定性，也沒有外部干擾，所以我們可以為名義動態設計一個狀態反饋控制器。使用系統數據和Maltlab，我們得到：</span></p>
<p></p>
<p><span style="font-weight: 400;">X =     1.1358    −0.3758</span></p>
<p><span style="font-weight: 400;">          −0.3758    1.1465 </span></p>
<p><span style="font-weight: 400;">Y =    −0.0092    0.0228</span></p>
<p></p>
<p><span style="font-weight: 400;">The corresponding controller gain is given:</span></p>
<p><span style="font-weight: 400;">給出了相應的控制器增益：</span></p>
<p></p>
<p><span style="font-weight: 400;">K =−0.0017 0.0193</span></p>
<p></p>
<p><span style="font-weight: 400;">Remark 11.3.3 Since we have the continuous-time model for the dc motor kit, we have use it to design the controller gain. In this case we have solved the following LMI:</span></p>
<p><span style="font-weight: 400;">備註11.3.3由於我們有直流電動機套件的連續時間模型，因此我們用它來設計控制器增益。在這種情況下，我們解決了以下LMI：</span></p>
<p></p>
<p><span style="font-weight: 400;">AX + XA + BY + YB &lt; 0</span></p>
<p></p>
<p><span style="font-weight: 400;">The gain K is given by: K = YX−1.</span></p>
<p><span style="font-weight: 400;">增益K由下式得出：K = YX-1。</span></p>
<p></p>
<p><span style="font-weight: 400;">For more detail on the continuous time case we refer the reader to Boukas [2] and the references therein.</span></p>
<p><span style="font-weight: 400;">有關連續時間情況的更多詳細信息，請向讀者介紹Boukas [2]及其中的參考文獻。</span></p>
<h1><span style="font-weight: 400;">Assignments</span></h1>
<p><a href="file:///E:/tmp/cd2020/downloads/Assignment%201.pdf">Assignment 1</a></p>
<p><a href="file:///E:/tmp/cd2020/downloads/Assignment%202%20.pdf">Assignment 2</a></p>